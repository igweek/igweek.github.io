<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script async src='https://www.googletagmanager.com/gtag/js?id=G-5KH0XJYCQ7'></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-5KH0XJYCQ7');</script><script defer src="https://umami.myla.eu.org/script.js" data-website-id="a7942b92-e528-4d9b-a65a-4c19d4a8b4f1"></script><script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://pic.myla.eu.org/file/29b29c1e2f4b11671ddca.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="
# Docker实验手册 (CentOS 8)

## 1. 引言

### 1.1 Docker简介

在当今的软件开发和部署领域，**容器化技术**已成为不可或缺的一部分。">
<meta property="og:title" content="Docker学习指南">
<meta property="og:description" content="
# Docker实验手册 (CentOS 8)

## 1. 引言

### 1.1 Docker简介

在当今的软件开发和部署领域，**容器化技术**已成为不可或缺的一部分。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://bbs.017121.xyz/post/100.html">
<meta property="og:image" content="https://pic.myla.eu.org/file/29b29c1e2f4b11671ddca.png">
<title>Docker学习指南</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Docker学习指南</h1>
<div class="title-right">
    <a href="https://bbs.017121.xyz" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/igweek/igweek.github.io/issues/100" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>Docker实验手册 (CentOS 8)</h1>
<h2>1. 引言</h2>
<h3>1.1 Docker简介</h3>
<p>在当今的软件开发和部署领域，<strong>容器化技术</strong>已成为不可或缺的一部分。Docker作为容器技术的领导者，通过提供一种轻量级、可移植、自给自足的打包机制，彻底改变了应用程序的构建、分发和运行方式。它允许开发者将应用程序及其所有依赖项（代码、运行时、系统工具、系统库等）打包到一个独立的<strong>镜像</strong>中，然后从这个镜像创建<strong>容器</strong>，确保应用程序在任何环境中都能以相同的方式运行，从而解决了“在我机器上可以运行”的问题。</p>
<p>Docker的核心优势在于其<strong>环境一致性</strong>、<strong>快速部署</strong>、<strong>资源隔离</strong>和<strong>高效利用</strong>。它极大地简化了开发、测试和生产环境之间的差异，加速了软件交付流程，并为微服务架构和DevOps实践提供了强大的支持。</p>
<h3>1.2 实验环境概述 (CentOS 8)</h3>
<p>本实验手册将以 <strong>CentOS 8</strong> 操作系统作为基础环境，详细指导您进行Docker的安装、配置和各项操作。CentOS 8作为一款稳定、企业级的Linux发行版，广泛应用于服务器环境。选择CentOS 8旨在模拟真实的生产环境，让您在实践中更好地理解Docker的部署和管理。</p>
<p>考虑到中国国内的网络环境特点，本手册还将特别强调<strong>配置国内镜像加速器</strong>的步骤，以确保您在拉取Docker镜像时能够获得流畅的体验。</p>
<h3>1.3 实验目的</h3>
<p>本实验手册旨在通过一系列详细的实践操作，帮助您全面掌握Docker的核心概念和常用命令，具体目标包括：</p>
<ul>
<li><strong>掌握Docker的安装与基本配置</strong>：在CentOS 8系统上成功安装Docker Engine，并配置国内镜像加速，以及设置非root用户使用Docker。</li>
<li><strong>熟悉Docker容器的生命周期管理</strong>：学会创建、启动、停止、重启、删除容器，并进行交互式操作、日志查看和资源监控。</li>
<li><strong>理解Docker镜像的管理</strong>：掌握镜像的获取、查看、删除、构建、标记、推送以及导入导出等操作。</li>
<li><strong>学会编写和使用Dockerfile</strong>：通过Dockerfile自动化构建自定义镜像，并了解多阶段构建和最佳实践。</li>
<li><strong>掌握Docker Compose进行多容器应用编排</strong>：使用<code class="notranslate">docker-compose.yml</code>文件定义和管理复杂的、多服务的应用程序。</li>
</ul>
<p>通过完成本手册中的所有实验，您将能够自信地在实际项目中运用Docker技术，提升您的开发和运维效率。</p>
<h1>2. Docker安装与配置</h1>
<p>本章节将详细指导如何在CentOS 8系统上安装Docker Engine，并进行必要的配置，包括国内镜像加速和非root用户使用Docker的设置。这些步骤旨在为后续的Docker实验提供一个稳定且高效的基础环境。</p>
<h2>2.1 系统要求与准备</h2>
<p>在开始安装Docker之前，请确保您的CentOS 8系统满足以下基本要求并完成必要的准备工作：</p>
<ul>
<li><strong>操作系统</strong>：CentOS 8 (或兼容的RHEL 8发行版)。</li>
<li><strong>内核版本</strong>：Docker要求Linux内核版本为3.10或更高。CentOS 8通常已满足此要求。</li>
<li><strong>硬件资源</strong>：建议至少2GB内存和20GB磁盘空间。</li>
<li><strong>网络连接</strong>：确保系统可以访问互联网以下载Docker软件包和镜像。</li>
<li><strong>更新系统</strong>：在安装任何新软件之前，始终建议更新系统软件包到最新版本，以确保兼容性和安全性 [1]。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo dnf update -y
sudo dnf install -y yum-utils device-mapper-persistent-data lvm2</pre></div>
<h2>2.2 Docker Engine安装 (CentOS 8)</h2>
<p>由于CentOS 8的官方软件源中可能不包含最新版本的Docker Engine，我们将使用Docker官方提供的仓库进行安装。以下是详细的安装步骤 [2]：</p>
<ol>
<li><strong>添加Docker官方仓库</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</pre></div>
<ol start="2">
<li>
<p><strong>安装Docker Engine</strong>：</p>
<p>安装最新版本的Docker Engine、Containerd和Docker Compose插件。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y</pre></div>
<ol start="3">
<li>
<p><strong>启动Docker服务</strong>：</p>
<p>安装完成后，启动Docker服务并设置开机自启。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl start docker
sudo systemctl <span class="pl-c1">enable</span> docker</pre></div>
<ol start="4">
<li>
<p><strong>验证安装</strong>：</p>
<p>运行一个简单的<code class="notranslate">hello-world</code>容器来验证Docker是否成功安装并正常运行。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo docker run hello-world</pre></div>
<pre class="notranslate"><code class="notranslate">如果一切正常，您将看到一条消息，表明Docker已成功安装。
</code></pre>
<h2>2.3 配置国内镜像加速</h2>
<p>在中国大陆地区，由于网络环境的限制，直接从Docker Hub拉取镜像可能会非常缓慢甚至失败。配置镜像加速器可以显著提高镜像下载速度。您可以选择阿里云、腾讯云、网易云等提供的公共镜像加速服务，或者使用DaoCloud等第三方服务 [3]。</p>
<p>以下以配置阿里云镜像加速器为例：</p>
<ol>
<li>
<p><strong>获取镜像加速地址</strong>：</p>
<p>访问阿里云容器镜像服务官网 (<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)%EF%BC%8C%E7%99%BB%E5%BD%95%E5%90%8E%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96%E6%82%A8%E7%9A%84%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E3%80%82" rel="nofollow">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)，登录后即可获取您的专属镜像加速地址。</a></p>
</li>
<li>
<p><strong>创建或修改Daemon配置文件</strong>：</p>
<p>Docker Daemon的配置文件位于<code class="notranslate">/etc/docker/daemon.json</code>。如果文件不存在，请创建它；如果存在，请编辑它。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <span class="pl-s"><span class="pl-k">&lt;&lt;</span>-"<span class="pl-k">EOF</span>"</span>
<span class="pl-s">{</span>
<span class="pl-s">  "registry-mirrors": ["https://&lt;your-mirror-id&gt;.mirror.aliyuncs.com"]</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：请将`https://&lt;your-mirror-id&gt;.mirror.aliyuncs.com`替换为您在阿里云获取的实际加速地址。
</code></pre>
<ol start="3">
<li>
<p><strong>重新加载并重启Docker服务</strong>：</p>
<p>修改配置文件后，需要重新加载systemd配置并重启Docker服务以使更改生效。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl daemon-reload
sudo systemctl restart docker</pre></div>
<pre class="notranslate"><code class="notranslate">您可以通过`docker info`命令查看`Registry Mirrors`部分，确认加速器是否配置成功。
</code></pre>
<h2>2.4 非root用户使用Docker</h2>
<p>默认情况下，<code class="notranslate">docker</code>命令需要root权限才能运行。为了方便日常操作，可以将当前用户添加到<code class="notranslate">docker</code>用户组，这样无需<code class="notranslate">sudo</code>即可运行Docker命令 [2]。</p>
<ol>
<li><strong>创建docker用户组（如果不存在）</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo groupadd docker</pre></div>
<ol start="2">
<li><strong>将当前用户添加到docker用户组</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo usermod -aG docker <span class="pl-smi">$USER</span></pre></div>
<ol start="3">
<li>
<p><strong>重新登录或重启</strong>：</p>
<p>为了使更改生效，您需要注销并重新登录您的会话，或者重启系统。执行以下命令可以测试是否生效：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run hello-world</pre></div>
<pre class="notranslate"><code class="notranslate">如果不再需要`sudo`即可运行`hello-world`，则表示配置成功。
</code></pre>
<h2>2.5 Docker服务管理</h2>
<p>了解如何管理Docker服务对于日常维护至关重要。以下是一些常用的<code class="notranslate">systemctl</code>命令，用于管理Docker守护进程：</p>
<ul>
<li><strong>启动Docker服务</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl start docker</pre></div>
<ul>
<li><strong>停止Docker服务</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl stop docker</pre></div>
<ul>
<li><strong>重启Docker服务</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl restart docker</pre></div>
<ul>
<li><strong>查看Docker服务状态</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl status docker</pre></div>
<ul>
<li><strong>设置Docker服务开机自启</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl <span class="pl-c1">enable</span> docker</pre></div>
<ul>
<li><strong>禁用Docker服务开机自启</strong>：</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo systemctl disable docker</pre></div>
<h1>3. Docker容器管理</h1>
<p>Docker容器是Docker的核心概念，它是一个轻量级、可移植、自给自足的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库等。本章节将详细介绍如何管理Docker容器的生命周期、进行常用操作、配置网络以及管理数据卷。</p>
<h2>3.1 容器生命周期管理</h2>
<p>容器的生命周期包括创建、启动、停止、重启和删除等阶段。掌握这些基本命令是进行Docker操作的基础。</p>
<h3>3.1.1 创建与启动容器 (<code class="notranslate">docker run</code>)</h3>
<p><code class="notranslate">docker run</code> 命令用于创建并启动一个新的容器。它是Docker中最常用的命令之一，拥有丰富的参数来控制容器的行为。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-d</code> 或 <code class="notranslate">--detach</code>：后台运行容器。</li>
<li><code class="notranslate">-p</code> 或 <code class="notranslate">--publish</code>：端口映射，格式为 <code class="notranslate">宿主机端口:容器端口</code>。</li>
<li><code class="notranslate">-v</code> 或 <code class="notranslate">--volume</code>：数据卷挂载，格式为 <code class="notranslate">宿主机路径:容器路径</code> 或 <code class="notranslate">数据卷名称:容器路径</code>。</li>
<li><code class="notranslate">--name</code>：为容器指定一个名称。</li>
<li><code class="notranslate">-it</code>：交互式运行容器，通常用于进入容器的shell。</li>
<li><code class="notranslate">--rm</code>：容器停止后自动删除。</li>
<li><code class="notranslate">--network</code>：指定容器连接的网络。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>运行一个Nginx Web服务器容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 8080:80 --name my-nginx nginx:latest</pre></div>
<pre class="notranslate"><code class="notranslate">此命令将从Docker Hub拉取`nginx:latest`镜像（如果本地没有），然后在后台运行一个名为`my-nginx`的容器，并将宿主机的8080端口映射到容器的80端口。
</code></pre>
<ol start="2">
<li><strong>运行一个交互式Ubuntu容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -it --rm ubuntu:latest bash</pre></div>
<pre class="notranslate"><code class="notranslate">此命令将启动一个Ubuntu容器，并进入其bash shell。`-it` 选项使得容器可以交互式运行，`--rm` 选项确保容器退出后自动删除。
</code></pre>
<h3>3.1.2 查看运行中的容器 (<code class="notranslate">docker ps</code>)</h3>
<p><code class="notranslate">docker ps</code> 命令用于列出当前正在运行的容器。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps [OPTIONS]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-a</code> 或 <code class="notranslate">--all</code>：显示所有容器，包括已停止的。</li>
<li><code class="notranslate">-s</code> 或 <code class="notranslate">--size</code>：显示容器的总文件大小。</li>
<li><code class="notranslate">-q</code> 或 <code class="notranslate">--quiet</code>：只显示容器ID。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看所有运行中的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps</pre></div>
<ol start="2">
<li><strong>查看所有容器（包括已停止的）</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps -a</pre></div>
<h3>3.1.3 停止、启动与重启容器 (<code class="notranslate">docker stop</code>, <code class="notranslate">docker start</code>, <code class="notranslate">docker restart</code>)</h3>
<p>这些命令用于控制容器的运行状态。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker stop [OPTIONS] CONTAINER [CONTAINER...]
docker start [OPTIONS] CONTAINER [CONTAINER...]
docker restart [OPTIONS] CONTAINER [CONTAINER...]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>停止名为<code class="notranslate">my-nginx</code>的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker stop my-nginx</pre></div>
<ol start="2">
<li><strong>启动已停止的<code class="notranslate">my-nginx</code>容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker start my-nginx</pre></div>
<ol start="3">
<li><strong>重启<code class="notranslate">my-nginx</code>容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker restart my-nginx</pre></div>
<h3>3.1.4 删除容器 (<code class="notranslate">docker rm</code>)</h3>
<p><code class="notranslate">docker rm</code> 命令用于删除一个或多个已停止的容器。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rm [OPTIONS] CONTAINER [CONTAINER...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--force</code>：强制删除运行中的容器。</li>
<li><code class="notranslate">-v</code> 或 <code class="notranslate">--volumes</code>：删除与容器关联的匿名数据卷。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>删除已停止的<code class="notranslate">my-nginx</code>容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rm my-nginx</pre></div>
<ol start="2">
<li><strong>强制删除运行中的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rm -f my-nginx</pre></div>
<h2>3.2 容器操作</h2>
<p>除了生命周期管理，Docker还提供了一系列命令来与容器进行交互和监控。</p>
<h3>3.2.1 进入容器 (<code class="notranslate">docker exec</code>)</h3>
<p><code class="notranslate">docker exec</code> 命令用于在运行中的容器内部执行命令，常用于进入容器的shell进行调试或配置。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-it</code>：交互式运行，并分配一个伪TTY。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>进入<code class="notranslate">my-nginx</code>容器的bash shell</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it my-nginx bash</pre></div>
<pre class="notranslate"><code class="notranslate">在容器内部，您可以像操作普通Linux系统一样执行命令，例如`ls -l /usr/share/nginx/html`。
</code></pre>
<h3>3.2.2 查看容器日志 (<code class="notranslate">docker logs</code>)</h3>
<p><code class="notranslate">docker logs</code> 命令用于获取容器的日志输出。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs [OPTIONS] CONTAINER</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--follow</code>：持续输出日志。</li>
<li><code class="notranslate">--tail</code>：显示日志的最后N行。</li>
<li><code class="notranslate">-t</code> 或 <code class="notranslate">--timestamps</code>：显示时间戳。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看<code class="notranslate">my-nginx</code>容器的实时日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs -f my-nginx</pre></div>
<h3>3.2.3 查看容器详细信息 (<code class="notranslate">docker inspect</code>)</h3>
<p><code class="notranslate">docker inspect</code> 命令返回Docker对象的低级信息，包括容器、镜像、网络、数据卷等。它以JSON格式输出详细配置。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker inspect [OPTIONS] NAME<span class="pl-k">|</span>ID [NAME<span class="pl-k">|</span>ID...]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看<code class="notranslate">my-nginx</code>容器的详细信息</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker inspect my-nginx</pre></div>
<h3>3.2.4 查看容器内进程 (<code class="notranslate">docker top</code>)</h3>
<p><code class="notranslate">docker top</code> 命令用于查看容器内部运行的进程。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker top CONTAINER [ps OPTIONS]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看<code class="notranslate">my-nginx</code>容器内的进程</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker top my-nginx</pre></div>
<h3>3.2.5 查看容器资源使用 (<code class="notranslate">docker stats</code>)</h3>
<p><code class="notranslate">docker stats</code> 命令用于实时显示一个或多个容器的资源使用情况，包括CPU、内存、网络I/O和块I/O。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker stats [OPTIONS] [CONTAINER...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">--no-stream</code>：不持续输出，只显示一次。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看所有运行中容器的资源使用情况</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker stats</pre></div>
<h2>3.3 容器网络</h2>
<p>Docker提供了强大的网络功能，允许容器之间以及容器与宿主机之间进行通信。Docker默认提供多种网络驱动，如<code class="notranslate">bridge</code>、<code class="notranslate">host</code>、<code class="notranslate">none</code>等，并支持用户自定义网络。</p>
<h3>3.3.1 查看网络 (<code class="notranslate">docker network ls</code>)</h3>
<p><code class="notranslate">docker network ls</code> 命令用于列出所有Docker网络。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network ls [OPTIONS]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>列出所有Docker网络</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network ls</pre></div>
<h3>3.3.2 创建自定义网络 (<code class="notranslate">docker network create</code>)</h3>
<p>创建自定义网络可以更好地隔离容器，并允许容器通过名称进行通信。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network create [OPTIONS] NETWORK</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">--driver</code>：指定网络驱动，默认为<code class="notranslate">bridge</code>。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>创建一个名为<code class="notranslate">my-app-network</code>的bridge网络</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network create my-app-network</pre></div>
<h3>3.3.3 连接容器到网络 (<code class="notranslate">docker network connect</code>)</h3>
<p>将运行中的容器连接到指定的网络。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network connect [OPTIONS] NETWORK CONTAINER</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>将<code class="notranslate">my-nginx</code>容器连接到<code class="notranslate">my-app-network</code></strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network connect my-app-network my-nginx</pre></div>
<h3>3.3.4 断开容器与网络的连接 (<code class="notranslate">docker network disconnect</code>)</h3>
<p>将容器从指定的网络中移除。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network disconnect [OPTIONS] NETWORK CONTAINER</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>将<code class="notranslate">my-nginx</code>容器从<code class="notranslate">my-app-network</code>断开</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network disconnect my-app-network my-nginx</pre></div>
<h3>3.3.5 删除网络 (<code class="notranslate">docker network rm</code>)</h3>
<p>删除一个或多个自定义网络。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network rm NETWORK [NETWORK...]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>删除<code class="notranslate">my-app-network</code></strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network rm my-app-network</pre></div>
<h2>3.4 容器数据卷</h2>
<p>数据卷是用于持久化Docker容器数据或在容器之间共享数据的首选机制。它独立于容器的生命周期，即使容器被删除，数据卷中的数据也不会丢失。</p>
<h3>3.4.1 创建数据卷 (<code class="notranslate">docker volume create</code>)</h3>
<p><code class="notranslate">docker volume create</code> 命令用于创建一个新的数据卷。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume create [OPTIONS] VOLUME</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>创建一个名为<code class="notranslate">my-data</code>的数据卷</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume create my-data</pre></div>
<h3>3.4.2 查看数据卷 (<code class="notranslate">docker volume ls</code>)</h3>
<p><code class="notranslate">docker volume ls</code> 命令用于列出所有Docker数据卷。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume ls [OPTIONS]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>列出所有数据卷</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume ls</pre></div>
<h3>3.4.3 挂载数据卷到容器 (<code class="notranslate">docker run -v</code>)</h3>
<p>在<code class="notranslate">docker run</code>命令中使用<code class="notranslate">-v</code>选项可以将数据卷挂载到容器内部。</p>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>运行一个Nginx容器，并将<code class="notranslate">my-data</code>数据卷挂载到<code class="notranslate">/usr/share/nginx/html</code></strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 8081:80 --name nginx-with-volume -v my-data:/usr/share/nginx/html nginx:latest</pre></div>
<pre class="notranslate"><code class="notranslate">现在，`my-data`数据卷中的内容将作为Nginx的网页根目录。
</code></pre>
<ol start="2">
<li><strong>通过绑定挂载（Bind Mount）将宿主机目录挂载到容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir -p <span class="pl-k">~</span>/nginx-html
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>&lt;h1&gt;Hello from Host!&lt;/h1&gt;<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/nginx-html/index.html
docker run -d -p 8082:80 --name nginx-bind-mount -v <span class="pl-k">~</span>/nginx-html:/usr/share/nginx/html nginx:latest</pre></div>
<pre class="notranslate"><code class="notranslate">这会将宿主机的`~/nginx-html`目录内容映射到容器的Nginx网页根目录。
</code></pre>
<h3>3.4.4 查看数据卷详细信息 (<code class="notranslate">docker volume inspect</code>)</h3>
<p><code class="notranslate">docker volume inspect</code> 命令用于查看数据卷的详细信息，包括其挂载点等。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume inspect [OPTIONS] VOLUME [VOLUME...]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看<code class="notranslate">my-data</code>数据卷的详细信息</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume inspect my-data</pre></div>
<h3>3.4.5 删除数据卷 (<code class="notranslate">docker volume rm</code>)</h3>
<p><code class="notranslate">docker volume rm</code> 命令用于删除一个或多个数据卷。请注意，只有当数据卷没有被任何容器使用时才能被删除。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume rm [OPTIONS] VOLUME [VOLUME...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--force</code>：强制删除正在使用的数据卷（不推荐）。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>删除<code class="notranslate">my-data</code>数据卷</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume rm my-data</pre></div>
<h3>3.4.6 清理未使用的本地数据卷 (<code class="notranslate">docker volume prune</code>)</h3>
<p><code class="notranslate">docker volume prune</code> 命令用于删除所有未被任何容器引用的本地数据卷。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume prune [OPTIONS]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>清理所有未使用的本地数据卷</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker volume prune</pre></div>
<p>通过本章节的学习和实践，您应该已经掌握了Docker容器的基本管理和操作，包括容器的生命周期、交互、监控、网络配置以及数据持久化。这些是构建和管理基于Docker的应用程序的关键技能。</p>
<h1>4. Docker镜像管理</h1>
<p>Docker镜像是一个轻量级、独立、可执行的软件包，它包含了运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。本章节将详细介绍如何获取、查看、删除、构建、标记、推送以及导入/导出Docker镜像。</p>
<h2>4.1 镜像获取 (<code class="notranslate">docker pull</code>)</h2>
<p><code class="notranslate">docker pull</code> 命令用于从远程镜像仓库（默认为Docker Hub）下载镜像到本地。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull [OPTIONS] NAME[:TAG<span class="pl-k">|</span>@DIGEST]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">--all-tags</code>：下载仓库中的所有标签镜像。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>拉取最新版Ubuntu镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull ubuntu:latest</pre></div>
<ol start="2">
<li><strong>拉取指定版本的Nginx镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull nginx:1.21</pre></div>
<h2>4.2 镜像查看 (<code class="notranslate">docker images</code>)</h2>
<p><code class="notranslate">docker images</code> 或 <code class="notranslate">docker image ls</code> 命令用于列出本地主机上的所有镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images [OPTIONS] [REPOSITORY]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-a</code> 或 <code class="notranslate">--all</code>：显示所有镜像（包括中间层镜像）。</li>
<li><code class="notranslate">-q</code> 或 <code class="notranslate">--quiet</code>：只显示镜像ID。</li>
<li><code class="notranslate">--filter</code>：根据条件过滤显示结果，例如 <code class="notranslate">dangling=true</code> (显示悬空镜像)。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>列出所有本地镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images</pre></div>
<ol start="2">
<li><strong>只显示镜像ID</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images -q</pre></div>
<ol start="3">
<li><strong>查看特定仓库的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images ubuntu</pre></div>
<h2>4.3 镜像删除 (<code class="notranslate">docker rmi</code>)</h2>
<p><code class="notranslate">docker rmi</code> 命令用于删除一个或多个本地镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi [OPTIONS] IMAGE [IMAGE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--force</code>：强制删除镜像，即使它被容器使用。</li>
<li><code class="notranslate">--no-prune</code>：不删除未被标记的父镜像。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>删除<code class="notranslate">nginx:1.21</code>镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi nginx:1.21</pre></div>
<ol start="2">
<li><strong>强制删除一个被容器使用的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi -f ubuntu:latest</pre></div>
<ol start="3">
<li><strong>删除所有悬空镜像（没有被任何标签引用的镜像）</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker image prune</pre></div>
<h2>4.4 镜像构建 (<code class="notranslate">docker build</code>)</h2>
<p><code class="notranslate">docker build</code> 命令用于根据Dockerfile文件和上下文构建新的Docker镜像。Dockerfile是一个文本文件，包含了一系列构建镜像的指令。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build [OPTIONS] PATH <span class="pl-k">|</span> URL <span class="pl-k">|</span> -</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-t</code> 或 <code class="notranslate">--tag</code>：为构建的镜像指定名称和标签，格式为 <code class="notranslate">name:tag</code>。</li>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--file</code>：指定Dockerfile文件的路径（如果不是默认的<code class="notranslate">./Dockerfile</code>）。</li>
<li><code class="notranslate">--no-cache</code>：构建镜像时不使用缓存。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li>
<p><strong>准备Dockerfile</strong>：</p>
<p>首先，创建一个名为<code class="notranslate">my-app</code>的目录，并在其中创建<code class="notranslate">Dockerfile</code>文件和<code class="notranslate">app.py</code>文件。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir -p my-app
cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; my-app/Dockerfile</span>
<span class="pl-s">FROM python:3.9-slim-buster</span>
<span class="pl-s">WORKDIR /app</span>
<span class="pl-s">COPY . .</span>
<span class="pl-s">RUN pip install Flask</span>
<span class="pl-s">EXPOSE 5000</span>
<span class="pl-s">CMD ["python", "app.py"]</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Flask<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> requirements.txt

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; my-app/app.py</span>
<span class="pl-s">from flask import Flask</span>
<span class="pl-s">app = Flask(__name__)</span>
<span class="pl-s"></span>
<span class="pl-s">@app.route("/")</span>
<span class="pl-s">def hello():</span>
<span class="pl-s">    return "Hello from Docker!"</span>
<span class="pl-s"></span>
<span class="pl-s">if __name__ == "__main__":</span>
<span class="pl-s">    app.run(host="0.0.0.0", port=5000)</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<ol start="2">
<li>
<p><strong>构建镜像</strong>：</p>
<p>在<code class="notranslate">my-app</code>目录下执行：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build -t my-python-app:1.0 my-app</pre></div>
<pre class="notranslate"><code class="notranslate">这里的`my-app`表示Dockerfile所在的上下文路径。
</code></pre>
<ol start="3">
<li><strong>运行构建的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 5000:5000 --name my-web-app my-python-app:1.0</pre></div>
<pre class="notranslate"><code class="notranslate">访问 `http://localhost:5000` 即可看到 "Hello from Docker!"。
</code></pre>
<h2>4.5 镜像标签与推送 (<code class="notranslate">docker tag</code>, <code class="notranslate">docker push</code>)</h2>
<p><code class="notranslate">docker tag</code> 命令用于为镜像添加一个额外的标签，通常用于将本地镜像标记为准备推送到远程仓库的格式。<code class="notranslate">docker push</code> 命令用于将本地镜像推送到远程镜像仓库。</p>
<h3>4.5.1 标记镜像 (<code class="notranslate">docker tag</code>)</h3>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li>
<p><strong>为<code class="notranslate">my-python-app:1.0</code>镜像添加一个新标签，准备推送到Docker Hub</strong>：</p>
<p>假设您的Docker Hub用户名为<code class="notranslate">your_dockerhub_username</code>。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker tag my-python-app:1.0 your_dockerhub_username/my-python-app:latest</pre></div>
<h3>4.5.2 登录Docker Hub (<code class="notranslate">docker login</code>)</h3>
<p>在推送镜像之前，您需要登录到Docker Hub或其他远程仓库。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker login [OPTIONS] [SERVER]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>登录Docker Hub</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker login</pre></div>
<pre class="notranslate"><code class="notranslate">系统会提示您输入Docker Hub用户名和密码。
</code></pre>
<h3>4.5.3 推送镜像 (<code class="notranslate">docker push</code>)</h3>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker push [OPTIONS] NAME[:TAG]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>推送<code class="notranslate">my-python-app</code>镜像到Docker Hub</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker push your_dockerhub_username/my-python-app:latest</pre></div>
<h2>4.6 镜像导入导出 (<code class="notranslate">docker save</code>, <code class="notranslate">docker load</code>)</h2>
<p><code class="notranslate">docker save</code> 和 <code class="notranslate">docker load</code> 命令用于将镜像打包成文件进行传输，或从文件加载镜像。</p>
<h3>4.6.1 导出镜像 (<code class="notranslate">docker save</code>)</h3>
<p><code class="notranslate">docker save</code> 命令将一个或多个镜像保存到一个tar归档文件中。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker save [OPTIONS] IMAGE [IMAGE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-o</code> 或 <code class="notranslate">--output</code>：指定输出文件路径。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>将<code class="notranslate">my-python-app:1.0</code>镜像保存到<code class="notranslate">my-python-app.tar</code>文件</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker save -o my-python-app.tar my-python-app:1.0</pre></div>
<h3>4.6.2 导入镜像 (<code class="notranslate">docker load</code>)</h3>
<p><code class="notranslate">docker load</code> 命令从一个tar归档文件或标准输入中加载镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker load [OPTIONS]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-i</code> 或 <code class="notranslate">--input</code>：指定输入文件路径。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>从<code class="notranslate">my-python-app.tar</code>文件加载镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker load -i my-python-app.tar</pre></div>
<p>通过本章节的学习和实践，您应该已经掌握了Docker镜像的完整生命周期管理，包括从远程仓库获取、本地查看与删除、通过Dockerfile构建自定义镜像、以及镜像的标记、推送、导入和导出。这些技能是高效利用Docker进行应用部署和分发的基础。</p>
<h1>5. Dockerfile</h1>
<p>Dockerfile是用于构建Docker镜像的文本文件，它包含了一系列指令，每条指令都在镜像中创建一个层。通过Dockerfile，我们可以自动化镜像的创建过程，实现可重复、版本化的镜像构建。本章节将深入探讨Dockerfile的基本语法、常用指令、构建自定义镜像、多阶段构建以及最佳实践。</p>
<h2>5.1 Dockerfile基本语法与指令</h2>
<p>Dockerfile中的指令按顺序执行，每条指令都会在镜像中创建一个新的层。以下是一些最常用的Dockerfile指令及其用途。</p>
<h3>5.1.1 <code class="notranslate">FROM</code></h3>
<p><code class="notranslate">FROM</code> 指令指定了新镜像所基于的基础镜像。所有Dockerfile都必须以 <code class="notranslate">FROM</code> 指令开始。</p>
<p><strong>语法</strong>：<code class="notranslate">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">FROM</span> ubuntu:22.04
<span class="pl-k">FROM</span> python:3.9-slim-buster AS builder</pre></div>
<h3>5.1.2 <code class="notranslate">RUN</code></h3>
<p><code class="notranslate">RUN</code> 指令用于在当前镜像层上执行命令，并提交结果。它通常用于安装软件包、创建文件或目录等。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code class="notranslate">RUN &lt;command&gt;</code> (shell 格式，命令在 <code class="notranslate">/bin/sh -c</code> 中运行)</li>
<li><code class="notranslate">RUN ["executable", "param1", "param2"]</code> (exec 格式，推荐，避免shell解释器问题)</li>
</ul>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">RUN</span> apt-get update &amp;&amp; apt-get install -y curl
<span class="pl-k">RUN</span> [<span class="pl-s">"/bin/bash"</span>, <span class="pl-s">"-c"</span>, <span class="pl-s">"echo hello"</span>]</pre></div>
<h3>5.1.3 <code class="notranslate">CMD</code></h3>
<p><code class="notranslate">CMD</code> 指令为执行中的容器提供默认的执行命令。如果 <code class="notranslate">docker run</code> 命令中指定了其他命令，则 <code class="notranslate">CMD</code> 命令会被覆盖。一个Dockerfile中只能有一个 <code class="notranslate">CMD</code> 指令，如果有多个，只有最后一个生效。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code class="notranslate">CMD ["executable","param1","param2"]</code> (exec 格式，推荐)</li>
<li><code class="notranslate">CMD ["param1","param2"]</code> (作为 <code class="notranslate">ENTRYPOINT</code> 的默认参数)</li>
<li><code class="notranslate">CMD command param1 param2</code> (shell 格式)</li>
</ul>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">CMD</span> [<span class="pl-s">"nginx"</span>, <span class="pl-s">"-g"</span>, <span class="pl-s">"daemon off;"</span>]
<span class="pl-k">CMD</span> [<span class="pl-s">"python"</span>, <span class="pl-s">"app.py"</span>]</pre></div>
<h3>5.1.4 <code class="notranslate">ENTRYPOINT</code></h3>
<p><code class="notranslate">ENTRYPOINT</code> 指令配置容器启动时执行的命令。与 <code class="notranslate">CMD</code> 不同，<code class="notranslate">ENTRYPOINT</code> 不会被 <code class="notranslate">docker run</code> 命令中指定的参数覆盖，而是将这些参数作为 <code class="notranslate">ENTRYPOINT</code> 命令的参数。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code class="notranslate">ENTRYPOINT ["executable", "param1", "param2"]</code> (exec 格式，推荐)</li>
<li><code class="notranslate">ENTRYPOINT command param1 param2</code> (shell 格式)</li>
</ul>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">ENTRYPOINT</span> [<span class="pl-s">"/usr/bin/cowsay"</span>]
<span class="pl-k">CMD</span> [<span class="pl-s">"hello world"</span>]</pre></div>
<p>运行 <code class="notranslate">docker run my-cowsay-image</code> 会输出 <code class="notranslate">hello world</code>。运行 <code class="notranslate">docker run my-cowsay-image moo</code> 会输出 <code class="notranslate">moo</code>。</p>
<h3>5.1.5 <code class="notranslate">COPY</code></h3>
<p><code class="notranslate">COPY</code> 指令将本地文件或目录复制到镜像中的指定路径。</p>
<p><strong>语法</strong>：<code class="notranslate">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">COPY</span> . /app
<span class="pl-k">COPY</span> requirements.txt /tmp/</pre></div>
<h3>5.1.6 <code class="notranslate">ADD</code></h3>
<p><code class="notranslate">ADD</code> 指令与 <code class="notranslate">COPY</code> 类似，但它支持URL和自动解压tar文件。通常推荐使用 <code class="notranslate">COPY</code>，因为它更透明。</p>
<p><strong>语法</strong>：<code class="notranslate">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">ADD</span> http://example.com/latest.tar.gz /tmp/
<span class="pl-k">ADD</span> app.tar.gz /app</pre></div>
<h3>5.1.7 <code class="notranslate">WORKDIR</code></h3>
<p><code class="notranslate">WORKDIR</code> 指令为Dockerfile中后续的 <code class="notranslate">RUN</code>, <code class="notranslate">CMD</code>, <code class="notranslate">ENTRYPOINT</code>, <code class="notranslate">COPY</code>, <code class="notranslate">ADD</code> 指令设置工作目录。</p>
<p><strong>语法</strong>：<code class="notranslate">WORKDIR /path/to/workdir</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">WORKDIR</span> /app
<span class="pl-k">COPY</span> . .
<span class="pl-k">RUN</span> ls</pre></div>
<h3>5.1.8 <code class="notranslate">EXPOSE</code></h3>
<p><code class="notranslate">EXPOSE</code> 指令声明容器在运行时监听的端口。它仅仅是声明，并不会实际发布端口，发布端口需要在使用 <code class="notranslate">docker run -p</code> 时指定。</p>
<p><strong>语法</strong>：<code class="notranslate">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">EXPOSE</span> 80
<span class="pl-k">EXPOSE</span> 80/tcp 443/tcp</pre></div>
<h3>5.1.9 <code class="notranslate">ENV</code></h3>
<p><code class="notranslate">ENV</code> 指令设置环境变量，这些变量在构建时和容器运行时都可用。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code class="notranslate">ENV &lt;key&gt;=&lt;value&gt; ...</code></li>
<li><code class="notranslate">ENV &lt;key&gt; &lt;value&gt;</code></li>
</ul>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">ENV</span> MY_VAR=<span class="pl-s">"hello world"</span>
<span class="pl-k">ENV</span> PATH=<span class="pl-s">"$PATH:/usr/local/bin"</span></pre></div>
<h3>5.1.10 <code class="notranslate">VOLUME</code></h3>
<p><code class="notranslate">VOLUME</code> 指令创建一个挂载点，将宿主机上的目录或另一个容器中的目录挂载到容器中，用于持久化数据或共享数据。</p>
<p><strong>语法</strong>：<code class="notranslate">VOLUME ["/data"]</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">VOLUME</span> /var/lib/mysql</pre></div>
<h3>5.1.11 <code class="notranslate">USER</code></h3>
<p><code class="notranslate">USER</code> 指令设置运行 <code class="notranslate">RUN</code>, <code class="notranslate">CMD</code>, <code class="notranslate">ENTRYPOINT</code> 指令的用户或UID。默认情况下，容器以root用户运行。</p>
<p><strong>语法</strong>：<code class="notranslate">USER &lt;user&gt;[:&lt;group&gt;]</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">USER</span> appuser</pre></div>
<h3>5.1.12 <code class="notranslate">ARG</code></h3>
<p><code class="notranslate">ARG</code> 指令定义了用户在 <code class="notranslate">docker build</code> 命令中使用 <code class="notranslate">--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志传递的构建时变量。</p>
<p><strong>语法</strong>：<code class="notranslate">ARG &lt;name&gt;[=&lt;default value&gt;]</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">ARG</span> VERSION=1.0
<span class="pl-k">RUN</span> echo <span class="pl-s">"Building version: $VERSION"</span></pre></div>
<h3>5.1.13 <code class="notranslate">LABEL</code></h3>
<p><code class="notranslate">LABEL</code> 指令为镜像添加元数据，例如维护者信息、版本号等。</p>
<p><strong>语法</strong>：<code class="notranslate">LABEL &lt;key&gt;="&lt;value&gt;" [&lt;key&gt;="&lt;value&gt;"]...</code></p>
<div class="highlight highlight-source-dockerfile"><pre class="notranslate"><span class="pl-k">LABEL</span> maintainer=<span class="pl-s">"Your Name &lt;your.email@example.com&gt;"</span>
<span class="pl-k">LABEL</span> version=<span class="pl-s">"1.0"</span></pre></div>
<h2>5.2 构建自定义镜像</h2>
<p>通过一个实际的例子来演示如何使用Dockerfile构建一个简单的Web应用镜像。</p>
<p><strong>实验目标</strong>：构建一个基于Python Flask的Web应用镜像。</p>
<ol>
<li><strong>创建项目目录和文件</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir my-flask-app
<span class="pl-c1">cd</span> my-flask-app

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; Dockerfile</span>
<span class="pl-s">FROM python:3.9-slim-buster</span>
<span class="pl-s">WORKDIR /app</span>
<span class="pl-s">COPY requirements.txt .</span>
<span class="pl-s">RUN pip install --no-cache-dir -r requirements.txt</span>
<span class="pl-s">COPY . .</span>
<span class="pl-s">EXPOSE 5000</span>
<span class="pl-s">CMD ["python3", "app.py"]</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Flask<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> requirements.txt

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; app.py</span>
<span class="pl-s">from flask import Flask</span>
<span class="pl-s">app = Flask(__name__)</span>
<span class="pl-s"></span>
<span class="pl-s">@app.route("/")</span>
<span class="pl-s">def hello():</span>
<span class="pl-s">    return "Hello from Flask in Docker!"</span>
<span class="pl-s"></span>
<span class="pl-s">if __name__ == "__main__":</span>
<span class="pl-s">    app.run(host="0.0.0.0", port=5000)</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<ol start="2">
<li>
<p><strong>构建镜像</strong>：</p>
<p>在<code class="notranslate">my-flask-app</code>目录下执行：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build -t my-flask-web-app:1.0 <span class="pl-c1">.</span></pre></div>
<pre class="notranslate"><code class="notranslate">这里的`.`表示Dockerfile所在的上下文路径。
</code></pre>
<ol start="3">
<li><strong>运行容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 5000:5000 --name flask-app-container my-flask-web-app:1.0</pre></div>
<ol start="4">
<li>
<p><strong>验证</strong>：</p>
<p>访问 <code class="notranslate">http://localhost:5000</code> 或 <code class="notranslate">http://&lt;your-server-ip&gt;:5000</code>，应该能看到 "Hello from Flask in Docker!"。</p>
</li>
</ol>
<h2>5.3 多阶段构建 (Multi-stage builds)</h2>
<p>多阶段构建允许您在Dockerfile中使用多个 <code class="notranslate">FROM</code> 语句，每个 <code class="notranslate">FROM</code> 语句可以开始一个新的构建阶段。这使得您可以将构建时所需的工具和依赖项与运行时所需的最终镜像分离开来，从而显著减小最终镜像的大小。</p>
<p><strong>实验目标</strong>：使用多阶段构建一个Go语言的Web应用，最终镜像只包含编译后的二进制文件。</p>
<ol>
<li><strong>创建项目目录和文件</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir my-go-app
<span class="pl-c1">cd</span> my-go-app

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; Dockerfile</span>
<span class="pl-s">FROM golang:1.20 AS builder</span>
<span class="pl-s">WORKDIR /app</span>
<span class="pl-s">COPY . .</span>
<span class="pl-s">RUN go mod init my-go-app &amp;&amp; go mod tidy</span>
<span class="pl-s">RUN CGO_ENABLED=0 GOOS=linux go build -o my-app .</span>
<span class="pl-s"></span>
<span class="pl-s">FROM alpine:latest</span>
<span class="pl-s">WORKDIR /root/</span>
<span class="pl-s">COPY --from=builder /app/my-app .</span>
<span class="pl-s">CMD ["./my-app"]</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; main.go</span>
<span class="pl-s">package main</span>
<span class="pl-s"></span>
<span class="pl-s">import (</span>
<span class="pl-s">	"fmt"</span>
<span class="pl-s">	"log"</span>
<span class="pl-s">	"net/http"</span>
<span class="pl-s">)</span>
<span class="pl-s"></span>
<span class="pl-s">func main() {</span>
<span class="pl-s">	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {</span>
<span class="pl-s">		fmt.Fprintf(w, "Hello from Go in Docker!")</span>
<span class="pl-s">	})</span>
<span class="pl-s">	fmt.Println("Server starting on port 8080...")</span>
<span class="pl-s">	log.Fatal(http.ListenAndServe(":8080", nil))</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<ol start="2">
<li>
<p><strong>构建镜像</strong>：</p>
<p>在<code class="notranslate">my-go-app</code>目录下执行：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build -t my-go-web-app:1.0 <span class="pl-c1">.</span></pre></div>
<ol start="3">
<li><strong>运行容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 8080:8080 --name go-app-container my-go-web-app:1.0</pre></div>
<ol start="4">
<li>
<p><strong>验证</strong>：</p>
<p>访问 <code class="notranslate">http://localhost:8080</code> 或 <code class="notranslate">http://&lt;your-server-ip&gt;:8080</code>，应该能看到 "Hello from Go in Docker!"。</p>
<p>您还可以比较 <code class="notranslate">golang:1.20</code> 镜像和 <code class="notranslate">alpine:latest</code> 镜像的大小，会发现最终的 <code class="notranslate">my-go-web-app:1.0</code> 镜像非常小。</p>
</li>
</ol>
<h2>5.4 Dockerfile最佳实践</h2>
<p>编写高效、安全、可维护的Dockerfile是Docker开发的关键。以下是一些推荐的最佳实践：</p>
<ul>
<li><strong>选择合适的基础镜像</strong>：选择尽可能小且官方支持的基础镜像，例如 <code class="notranslate">alpine</code>、<code class="notranslate">slim</code> 版本，以减小最终镜像大小。</li>
<li><strong>利用构建缓存</strong>：Docker会缓存每个构建步骤。将不经常变化的指令放在Dockerfile的前面，将经常变化的指令（如 <code class="notranslate">COPY . .</code>）放在后面，以最大限度地利用缓存。</li>
<li><strong>减少镜像层数</strong>：将多个 <code class="notranslate">RUN</code> 命令合并为一个，使用 <code class="notranslate">&amp;&amp;</code> 连接，并清理不再需要的包和缓存，例如 <code class="notranslate">apt-get clean</code>。</li>
<li><strong>使用 <code class="notranslate">.dockerignore</code> 文件</strong>：类似于 <code class="notranslate">.gitignore</code>，<code class="notranslate">.dockerignore</code> 文件可以排除构建上下文中的不必要文件，减少传输到Docker守护进程的数据量，加快构建速度。</li>
<li><strong>明确指定版本</strong>：在 <code class="notranslate">FROM</code>、<code class="notranslate">RUN apt-get install</code> 等指令中明确指定镜像和软件包的版本，避免不确定性。</li>
<li><strong>非root用户运行</strong>：为了安全起见，尽量避免以root用户运行容器。在Dockerfile中使用 <code class="notranslate">USER</code> 指令切换到非root用户。</li>
<li><strong>使用 <code class="notranslate">ENTRYPOINT</code> 和 <code class="notranslate">CMD</code> 的exec格式</strong>：exec格式更清晰，且能更好地处理信号。</li>
<li><strong>多阶段构建</strong>：对于需要编译的应用程序（如Go、Java、Node.js），使用多阶段构建可以显著减小最终镜像的大小。</li>
<li><strong>避免安装不必要的软件包</strong>：只安装应用程序运行所需的最小依赖。</li>
<li><strong>使用健康检查</strong>：在Dockerfile中添加 <code class="notranslate">HEALTHCHECK</code> 指令，让Docker知道容器何时准备好处理请求。</li>
</ul>
<p>通过遵循这些最佳实践，您可以创建出更优化、更安全的Docker镜像，从而提升应用程序的部署效率和稳定性。</p>
<h1>4. Docker镜像管理</h1>
<p>Docker镜像是一个轻量级、独立、可执行的软件包，它包含了运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。本章节将详细介绍如何获取、查看、删除、构建、标记、推送以及导入/导出Docker镜像。</p>
<h2>4.1 镜像获取 (<code class="notranslate">docker pull</code>)</h2>
<p><code class="notranslate">docker pull</code> 命令用于从远程镜像仓库（默认为Docker Hub）下载镜像到本地。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull [OPTIONS] NAME[:TAG<span class="pl-k">|</span>@DIGEST]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">--all-tags</code>：下载仓库中的所有标签镜像。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>拉取最新版Ubuntu镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull ubuntu:latest</pre></div>
<ol start="2">
<li><strong>拉取指定版本的Nginx镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker pull nginx:1.21</pre></div>
<h2>4.2 镜像查看 (<code class="notranslate">docker images</code>)</h2>
<p><code class="notranslate">docker images</code> 或 <code class="notranslate">docker image ls</code> 命令用于列出本地主机上的所有镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images [OPTIONS] [REPOSITORY]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-a</code> 或 <code class="notranslate">--all</code>：显示所有镜像（包括中间层镜像）。</li>
<li><code class="notranslate">-q</code> 或 <code class="notranslate">--quiet</code>：只显示镜像ID。</li>
<li><code class="notranslate">--filter</code>：根据条件过滤显示结果，例如 <code class="notranslate">dangling=true</code> (显示悬空镜像)。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>列出所有本地镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images</pre></div>
<ol start="2">
<li><strong>只显示镜像ID</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images -q</pre></div>
<ol start="3">
<li><strong>查看特定仓库的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker images ubuntu</pre></div>
<h2>4.3 镜像删除 (<code class="notranslate">docker rmi</code>)</h2>
<p><code class="notranslate">docker rmi</code> 命令用于删除一个或多个本地镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi [OPTIONS] IMAGE [IMAGE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--force</code>：强制删除镜像，即使它被容器使用。</li>
<li><code class="notranslate">--no-prune</code>：不删除未被标记的父镜像。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>删除<code class="notranslate">nginx:1.21</code>镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi nginx:1.21</pre></div>
<ol start="2">
<li><strong>强制删除一个被容器使用的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker rmi -f ubuntu:latest</pre></div>
<ol start="3">
<li><strong>删除所有悬空镜像（没有被任何标签引用的镜像）</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker image prune</pre></div>
<h2>4.4 镜像构建 (<code class="notranslate">docker build</code>)</h2>
<p><code class="notranslate">docker build</code> 命令用于根据Dockerfile文件和上下文构建新的Docker镜像。Dockerfile是一个文本文件，包含了一系列构建镜像的指令。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build [OPTIONS] PATH <span class="pl-k">|</span> URL <span class="pl-k">|</span> -</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-t</code> 或 <code class="notranslate">--tag</code>：为构建的镜像指定名称和标签，格式为 <code class="notranslate">name:tag</code>。</li>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--file</code>：指定Dockerfile文件的路径（如果不是默认的<code class="notranslate">./Dockerfile</code>）。</li>
<li><code class="notranslate">--no-cache</code>：构建镜像时不使用缓存。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li>
<p><strong>准备Dockerfile</strong>：</p>
<p>首先，创建一个名为<code class="notranslate">my-app</code>的目录，并在其中创建<code class="notranslate">Dockerfile</code>文件和<code class="notranslate">app.py</code>文件。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir -p my-app
cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; my-app/Dockerfile</span>
<span class="pl-s">FROM python:3.9-slim-buster</span>
<span class="pl-s">WORKDIR /app</span>
<span class="pl-s">COPY . .</span>
<span class="pl-s">RUN pip install Flask</span>
<span class="pl-s">EXPOSE 5000</span>
<span class="pl-s">CMD ["python", "app.py"]</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Flask<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> requirements.txt

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; my-app/app.py</span>
<span class="pl-s">from flask import Flask</span>
<span class="pl-s">app = Flask(__name__)</span>
<span class="pl-s"></span>
<span class="pl-s">@app.route("/")</span>
<span class="pl-s">def hello():</span>
<span class="pl-s">    return "Hello from Docker!"</span>
<span class="pl-s"></span>
<span class="pl-s">if __name__ == "__main__":</span>
<span class="pl-s">    app.run(host="0.0.0.0", port=5000)</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<ol start="2">
<li>
<p><strong>构建镜像</strong>：</p>
<p>在<code class="notranslate">my-app</code>目录下执行：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker build -t my-python-app:1.0 my-app</pre></div>
<pre class="notranslate"><code class="notranslate">这里的`my-app`表示Dockerfile所在的上下文路径。
</code></pre>
<ol start="3">
<li><strong>运行构建的镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run -d -p 5000:5000 --name my-web-app my-python-app:1.0</pre></div>
<pre class="notranslate"><code class="notranslate">访问 `http://localhost:5000` 即可看到 "Hello from Docker!"。
</code></pre>
<h2>4.5 镜像标签与推送 (<code class="notranslate">docker tag</code>, <code class="notranslate">docker push</code>)</h2>
<p><code class="notranslate">docker tag</code> 命令用于为镜像添加一个额外的标签，通常用于将本地镜像标记为准备推送到远程仓库的格式。<code class="notranslate">docker push</code> 命令用于将本地镜像推送到远程镜像仓库。</p>
<h3>4.5.1 标记镜像 (<code class="notranslate">docker tag</code>)</h3>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li>
<p><strong>为<code class="notranslate">my-python-app:1.0</code>镜像添加一个新标签，准备推送到Docker Hub</strong>：</p>
<p>假设您的Docker Hub用户名为<code class="notranslate">your_dockerhub_username</code>。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker tag my-python-app:1.0 your_dockerhub_username/my-python-app:latest</pre></div>
<h3>4.5.2 登录Docker Hub (<code class="notranslate">docker login</code>)</h3>
<p>在推送镜像之前，您需要登录到Docker Hub或其他远程仓库。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker login [OPTIONS] [SERVER]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>登录Docker Hub</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker login</pre></div>
<pre class="notranslate"><code class="notranslate">系统会提示您输入Docker Hub用户名和密码。
</code></pre>
<h3>4.5.3 推送镜像 (<code class="notranslate">docker push</code>)</h3>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker push [OPTIONS] NAME[:TAG]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>推送<code class="notranslate">my-python-app</code>镜像到Docker Hub</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker push your_dockerhub_username/my-python-app:latest</pre></div>
<h2>4.6 镜像导入导出 (<code class="notranslate">docker save</code>, <code class="notranslate">docker load</code>)</h2>
<p><code class="notranslate">docker save</code> 和 <code class="notranslate">docker load</code> 命令用于将镜像打包成文件进行传输，或从文件加载镜像。</p>
<h3>4.6.1 导出镜像 (<code class="notranslate">docker save</code>)</h3>
<p><code class="notranslate">docker save</code> 命令将一个或多个镜像保存到一个tar归档文件中。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker save [OPTIONS] IMAGE [IMAGE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-o</code> 或 <code class="notranslate">--output</code>：指定输出文件路径。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>将<code class="notranslate">my-python-app:1.0</code>镜像保存到<code class="notranslate">my-python-app.tar</code>文件</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker save -o my-python-app.tar my-python-app:1.0</pre></div>
<h3>4.6.2 导入镜像 (<code class="notranslate">docker load</code>)</h3>
<p><code class="notranslate">docker load</code> 命令从一个tar归档文件或标准输入中加载镜像。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker load [OPTIONS]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-i</code> 或 <code class="notranslate">--input</code>：指定输入文件路径。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>从<code class="notranslate">my-python-app.tar</code>文件加载镜像</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker load -i my-python-app.tar</pre></div>
<p>通过本章节的学习和实践，您应该已经掌握了Docker镜像的完整生命周期管理，包括从远程仓库获取、本地查看与删除、通过Dockerfile构建自定义镜像、以及镜像的标记、推送、导入和导出。这些技能是高效利用Docker进行应用部署和分发的基础。</p>
<h1>6. Docker Compose</h1>
<p>Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。通过一个YAML文件来配置应用程序的服务，然后使用一个命令即可从配置中创建并启动所有服务。这使得管理复杂的、多服务的应用程序变得非常简单。本章节将介绍Docker Compose的安装、<code class="notranslate">docker-compose.yml</code>文件的编写以及常用命令。</p>
<h2>6.1 Docker Compose简介与安装</h2>
<h3>6.1.1 Docker Compose简介</h3>
<p>在实际应用中，一个完整的应用程序往往由多个服务组成，例如Web服务器、数据库、缓存等。这些服务可能需要运行在不同的容器中，并且它们之间需要相互通信。手动管理这些容器（创建、启动、连接）会非常繁琐。Docker Compose正是为了解决这个问题而生，它允许您：</p>
<ul>
<li><strong>使用YAML文件定义应用程序的服务</strong>：在一个文件中配置所有服务，包括镜像、端口映射、数据卷、网络等。</li>
<li><strong>一键启动所有服务</strong>：通过一个命令启动、停止、重建和查看所有服务。</li>
<li><strong>服务间通信</strong>：Compose会自动为服务创建网络，使得服务可以通过服务名称相互发现和通信。</li>
</ul>
<h3>6.1.2 Docker Compose安装</h3>
<p>在CentOS 8上，Docker Compose通常作为Docker Engine的一部分，通过<code class="notranslate">docker-compose-plugin</code>包进行安装。如果您在安装Docker Engine时已经包含了此插件，则无需额外安装。您可以通过运行<code class="notranslate">docker compose version</code>命令来验证是否已安装。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose version</pre></div>
<p>如果显示版本信息，则表示已安装。如果未安装，或者您需要安装独立版本的Docker Compose（旧版本），可以按照以下步骤进行：</p>
<ol>
<li><strong>下载Docker Compose二进制文件</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo curl -L <span class="pl-s"><span class="pl-pds">"</span>https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-<span class="pl-s"><span class="pl-pds">$(</span>uname -s<span class="pl-pds">)</span></span>-<span class="pl-s"><span class="pl-pds">$(</span>uname -m<span class="pl-pds">)</span></span><span class="pl-pds">"</span></span> -o /usr/local/bin/docker-compose</pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：请根据实际情况替换`v2.23.3`为最新稳定版本。
</code></pre>
<ol start="2">
<li><strong>添加执行权限</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo chmod +x /usr/local/bin/docker-compose</pre></div>
<ol start="3">
<li><strong>验证安装</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker-compose --version</pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：新版本的Docker Compose作为Docker CLI的插件，命令是`docker compose` (无连字符)。旧版本独立安装的命令是`docker-compose` (有连字符)。本手册将主要使用`docker compose`命令。
</code></pre>
<h2>6.2 <code class="notranslate">docker-compose.yml</code> 文件编写</h2>
<p><code class="notranslate">docker-compose.yml</code> 是Docker Compose的核心配置文件，它使用YAML格式定义了应用程序的服务、网络和数据卷。以下是其主要结构和常用配置项。</p>
<h3>6.2.1 文件结构</h3>
<p>一个典型的<code class="notranslate">docker-compose.yml</code>文件包含以下顶级键：</p>
<ul>
<li><code class="notranslate">version</code>：指定Compose文件的版本，通常建议使用最新版本（如<code class="notranslate">3.8</code>）。</li>
<li><code class="notranslate">services</code>：定义应用程序中的各个服务。每个服务都将运行在一个独立的容器中。</li>
<li><code class="notranslate">networks</code>：定义应用程序使用的网络。</li>
<li><code class="notranslate">volumes</code>：定义应用程序使用的数据卷。</li>
</ul>
<h3>6.2.2 <code class="notranslate">services</code> 配置项</h3>
<p><code class="notranslate">services</code> 部分是<code class="notranslate">docker-compose.yml</code>文件中最重要的部分，它定义了应用程序的各个组件。每个服务可以配置以下常用属性：</p>
<ul>
<li><code class="notranslate">image</code>：指定用于创建容器的镜像。</li>
<li><code class="notranslate">build</code>：指定Dockerfile的路径，用于构建自定义镜像。</li>
<li><code class="notranslate">ports</code>：端口映射，格式与<code class="notranslate">docker run -p</code>类似。</li>
<li><code class="notranslate">volumes</code>：数据卷挂载，格式与<code class="notranslate">docker run -v</code>类似。</li>
<li><code class="notranslate">environment</code>：设置环境变量。</li>
<li><code class="notranslate">depends_on</code>：定义服务之间的依赖关系，确保依赖服务先启动。</li>
<li><code class="notranslate">networks</code>：指定服务连接的网络。</li>
<li><code class="notranslate">restart</code>：定义容器的重启策略（如<code class="notranslate">always</code>, <code class="notranslate">on-failure</code>, <code class="notranslate">no</code>）。</li>
</ul>
<p><strong>示例 <code class="notranslate">docker-compose.yml</code> 文件</strong>：</p>
<p>我们将创建一个包含一个Web服务（Nginx）和一个数据库服务（MySQL）的简单应用。</p>
<div class="highlight highlight-source-yaml"><pre class="notranslate"><span class="pl-ent">version</span>: <span class="pl-s"><span class="pl-pds">'</span>3.8<span class="pl-pds">'</span></span>

<span class="pl-ent">services</span>:
  <span class="pl-ent">web</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">nginx:latest</span>
    <span class="pl-ent">ports</span>:
      - <span class="pl-s"><span class="pl-pds">"</span>80:80<span class="pl-pds">"</span></span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s">./nginx/conf.d:/etc/nginx/conf.d</span>
      - <span class="pl-s">./nginx/html:/usr/share/nginx/html</span>
    <span class="pl-ent">depends_on</span>:
      - <span class="pl-s">db</span>
    <span class="pl-ent">networks</span>:
      - <span class="pl-s">app-network</span>

  <span class="pl-ent">db</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">mysql:8.0</span>
    <span class="pl-ent">environment</span>:
      <span class="pl-ent">MYSQL_ROOT_PASSWORD</span>: <span class="pl-s">root_password</span>
      <span class="pl-ent">MYSQL_DATABASE</span>: <span class="pl-s">my_database</span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s">db_data:/var/lib/mysql</span>
    <span class="pl-ent">networks</span>:
      - <span class="pl-s">app-network</span>

<span class="pl-ent">networks</span>:
  <span class="pl-ent">app-network</span>:
    <span class="pl-ent">driver</span>: <span class="pl-s">bridge</span>

<span class="pl-ent">volumes</span>:
  <span class="pl-ent">db_data</span>:</pre></div>
<p><strong>文件说明</strong>：</p>
<ul>
<li><strong><code class="notranslate">web</code> 服务</strong>：
<ul>
<li>使用 <code class="notranslate">nginx:latest</code> 镜像。</li>
<li>将宿主机的80端口映射到容器的80端口。</li>
<li>挂载本地 <code class="notranslate">./nginx/conf.d</code> 和 <code class="notranslate">./nginx/html</code> 目录到容器内，用于Nginx配置和网页文件。</li>
<li><code class="notranslate">depends_on: - db</code> 表示 <code class="notranslate">web</code> 服务依赖于 <code class="notranslate">db</code> 服务，<code class="notranslate">db</code> 服务会先启动。</li>
<li>连接到 <code class="notranslate">app-network</code> 网络。</li>
</ul>
</li>
<li><strong><code class="notranslate">db</code> 服务</strong>：
<ul>
<li>使用 <code class="notranslate">mysql:8.0</code> 镜像。</li>
<li>设置MySQL的root密码和数据库名称环境变量。</li>
<li>使用名为 <code class="notranslate">db_data</code> 的数据卷来持久化MySQL数据。</li>
<li>连接到 <code class="notranslate">app-network</code> 网络。</li>
</ul>
</li>
<li><strong><code class="notranslate">networks</code> 部分</strong>：
<ul>
<li>定义了一个名为 <code class="notranslate">app-network</code> 的自定义桥接网络，所有服务都将连接到此网络。</li>
</ul>
</li>
<li><strong><code class="notranslate">volumes</code> 部分</strong>：
<ul>
<li>定义了一个名为 <code class="notranslate">db_data</code> 的数据卷，用于 <code class="notranslate">db</code> 服务的持久化存储。</li>
</ul>
</li>
</ul>
<h2>6.3 多容器应用编排</h2>
<p>使用<code class="notranslate">docker-compose.yml</code>文件定义好应用程序后，就可以使用<code class="notranslate">docker compose</code>命令来管理整个应用栈。</p>
<h3>6.3.1 启动应用 (<code class="notranslate">docker compose up</code>)</h3>
<p><code class="notranslate">docker compose up</code> 命令会根据<code class="notranslate">docker-compose.yml</code>文件创建并启动所有服务。如果服务所需的镜像不存在，它会自动拉取；如果服务容器已存在，它会尝试重建或更新。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose up [OPTIONS] [SERVICE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-d</code> 或 <code class="notranslate">--detach</code>：在后台运行容器。</li>
<li><code class="notranslate">--build</code>：在启动前重新构建服务镜像。</li>
<li><code class="notranslate">--force-recreate</code>：强制重新创建容器。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li>
<p><strong>准备Nginx配置和网页文件</strong>：</p>
<p>在<code class="notranslate">docker-compose.yml</code>文件同级目录下创建<code class="notranslate">nginx</code>目录，并在其中创建<code class="notranslate">conf.d</code>和<code class="notranslate">html</code>子目录。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir -p nginx/conf.d
mkdir -p nginx/html

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; nginx/conf.d/default.conf</span>
<span class="pl-s">server {</span>
<span class="pl-s">    listen 80;</span>
<span class="pl-s">    location / {</span>
<span class="pl-s">        root /usr/share/nginx/html;</span>
<span class="pl-s">        index index.html;</span>
<span class="pl-s">    }</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; nginx/html/index.html</span>
<span class="pl-s">&lt;!DOCTYPE html&gt;</span>
<span class="pl-s">&lt;html&gt;</span>
<span class="pl-s">&lt;head&gt;</span>
<span class="pl-s">    &lt;title&gt;Docker Compose Nginx&lt;/title&gt;</span>
<span class="pl-s">&lt;/head&gt;</span>
<span class="pl-s">&lt;body&gt;</span>
<span class="pl-s">    &lt;h1&gt;Hello from Nginx via Docker Compose!&lt;/h1&gt;</span>
<span class="pl-s">    &lt;p&gt;This is a multi-container application example.&lt;/p&gt;</span>
<span class="pl-s">&lt;/body&gt;</span>
<span class="pl-s">&lt;/html&gt;</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<ol start="2">
<li>
<p><strong>启动应用程序</strong>：</p>
<p>在包含<code class="notranslate">docker-compose.yml</code>文件的目录下执行：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose up -d</pre></div>
<pre class="notranslate"><code class="notranslate">这将启动 `web` 和 `db` 两个服务。
</code></pre>
<ol start="3">
<li>
<p><strong>验证</strong>：</p>
<p>访问 <code class="notranslate">http://localhost:80</code> 或 <code class="notranslate">http://&lt;your-server-ip&gt;:80</code>，应该能看到Nginx提供的网页。</p>
</li>
</ol>
<h3>6.3.2 停止并移除应用 (<code class="notranslate">docker compose down</code>)</h3>
<p><code class="notranslate">docker compose down</code> 命令会停止并移除<code class="notranslate">docker-compose.yml</code>文件中定义的所有服务、网络和数据卷（除非数据卷被明确声明为外部的）。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose down [OPTIONS]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">--volumes</code> 或 <code class="notranslate">-v</code>：同时移除匿名数据卷和在<code class="notranslate">volumes</code>部分定义的数据卷。</li>
<li><code class="notranslate">--rmi all</code>：移除所有镜像。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>停止并移除应用程序</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose down</pre></div>
<ol start="2">
<li><strong>停止并移除应用程序，包括数据卷</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose down -v</pre></div>
<h3>6.3.3 查看服务状态 (<code class="notranslate">docker compose ps</code>)</h3>
<p><code class="notranslate">docker compose ps</code> 命令用于列出Compose项目中所有服务的运行状态。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose ps [OPTIONS] [SERVICE...]</pre></div>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看所有服务的状态</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose ps</pre></div>
<h3>6.3.4 查看服务日志 (<code class="notranslate">docker compose logs</code>)</h3>
<p><code class="notranslate">docker compose logs</code> 命令用于查看Compose项目中所有服务或指定服务的日志输出。</p>
<p><strong>基本语法</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs [OPTIONS] [SERVICE...]</pre></div>
<p><strong>常用选项</strong>：</p>
<ul>
<li><code class="notranslate">-f</code> 或 <code class="notranslate">--follow</code>：持续输出日志。</li>
<li><code class="notranslate">--tail</code>：显示日志的最后N行。</li>
</ul>
<p><strong>实验示例</strong>：</p>
<ol>
<li><strong>查看所有服务的实时日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs -f</pre></div>
<ol start="2">
<li><strong>查看<code class="notranslate">web</code>服务的日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs web</pre></div>
<h2>6.4 Compose常用命令</h2>
<p>除了上述命令，Docker Compose还提供了一些其他有用的命令：</p>
<ul>
<li><strong><code class="notranslate">docker compose build</code></strong>：构建（或重新构建）服务镜像。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose build [SERVICE...]</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose start</code></strong>：启动已停止的服务容器。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose start [SERVICE...]</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose stop</code></strong>：停止运行中的服务容器，但不删除它们。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose stop [SERVICE...]</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose restart</code></strong>：重启服务容器。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose restart [SERVICE...]</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose exec</code></strong>：在运行中的服务容器中执行命令。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose <span class="pl-c1">exec</span> web bash</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose config</code></strong>：验证并查看Compose文件的配置。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose config</pre></div>
<ul>
<li><strong><code class="notranslate">docker compose pull</code></strong>：拉取服务所需的镜像。</li>
</ul>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose pull [SERVICE...]</pre></div>
<p>通过本章节的学习和实践，您应该已经掌握了Docker Compose的基本概念、<code class="notranslate">docker-compose.yml</code>文件的编写以及如何使用<code class="notranslate">docker compose</code>命令来管理多容器应用程序。Docker Compose极大地简化了复杂应用的部署和管理，是Docker生态系统中不可或缺的工具。</p>
<h1>7. 总结与展望</h1>
<h2>7.1 实验回顾</h2>
<p>通过本实验手册的学习和实践，您已经全面掌握了Docker在CentOS 8环境下的核心技术。我们从Docker的安装与国内镜像加速配置开始，逐步深入到容器的生命周期管理、交互操作、网络配置和数据持久化。随后，我们探讨了镜像的获取、查看、删除、构建、标记、推送以及导入导出等管理操作。接着，我们学习了如何编写Dockerfile来自动化镜像构建，并了解了多阶段构建的优势和Dockerfile的最佳实践。最后，我们掌握了Docker Compose，通过YAML文件编排和管理多容器应用程序，极大地提升了应用部署和管理的效率。</p>
<p>这些实验不仅覆盖了Docker的常用命令，还通过实际案例帮助您理解了Docker在实际应用中的工作原理和最佳实践。您现在应该能够独立地在CentOS 8系统上部署、管理和维护基于Docker的应用程序。</p>
<h2>7.2 Docker生态系统简述</h2>
<p>Docker不仅仅是一个容器运行时，它更是一个庞大的生态系统，围绕着容器技术提供了丰富的工具和服务：</p>
<ul>
<li><strong>Docker Hub</strong>：官方的公共镜像仓库，提供了海量的官方和社区镜像。</li>
<li><strong>Docker Desktop</strong>：适用于Windows和macOS的桌面应用程序，提供了Docker Engine、Kubernetes、Compose等工具的集成环境。</li>
<li><strong>Docker Swarm</strong>：Docker官方提供的容器编排工具，用于管理和部署集群中的容器。</li>
<li><strong>Kubernetes (K8s)</strong>：目前最流行的容器编排系统，由Google开源，提供了更强大的自动化部署、扩展和管理容器化应用的能力。</li>
<li><strong>Containerd</strong>：一个行业标准的容器运行时，Docker Engine底层就是使用Containerd来管理容器生命周期。</li>
<li><strong>BuildKit</strong>：一个改进的镜像构建引擎，提供了更快的构建速度和更丰富的功能。</li>
</ul>
<h2>7.3 未来学习方向</h2>
<p>掌握了Docker的基础知识和实践技能后，您可以进一步探索以下方向，以深化您的容器化技术栈：</p>
<ul>
<li><strong>Kubernetes</strong>：学习Kubernetes是容器化技术进阶的必经之路，它能帮助您管理大规模的容器集群和复杂的微服务架构。</li>
<li><strong>CI/CD与DevOps</strong>：将Docker集成到持续集成/持续部署（CI/CD）流程中，实现自动化测试、构建和部署。</li>
<li><strong>容器安全</strong>：深入了解容器安全最佳实践，包括镜像扫描、运行时安全、网络隔离等。</li>
<li><strong>服务网格 (Service Mesh)</strong>：如Istio、Linkerd等，用于管理微服务之间的通信，提供流量控制、可观测性和安全性。</li>
<li><strong>无服务器计算 (Serverless)</strong>：结合容器技术，探索AWS Lambda、Google Cloud Functions等无服务器平台。</li>
<li><strong>云原生应用开发</strong>：学习如何设计和开发符合云原生原则的应用程序，充分利用容器和微服务架构的优势。</li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://bbs.017121.xyz">Gweek</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","igweek/igweek.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
