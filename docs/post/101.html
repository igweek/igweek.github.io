<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script async src='https://www.googletagmanager.com/gtag/js?id=G-5KH0XJYCQ7'></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-5KH0XJYCQ7');</script><script defer src="https://umami.myla.eu.org/script.js" data-website-id="a7942b92-e528-4d9b-a65a-4c19d4a8b4f1"></script><script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://pic.myla.eu.org/file/29b29c1e2f4b11671ddca.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 一、Docker安装wordpress
 
## 1. 引言
 
### 1.1 WordPress简介

#### wordpress

WordPress是一款全球领先的开源内容管理系统（CMS），以其强大的功能、灵活的扩展性和友好的用户界面而广受欢迎。">
<meta property="og:title" content="Docker安装wordpress">
<meta property="og:description" content="# 一、Docker安装wordpress
 
## 1. 引言
 
### 1.1 WordPress简介

#### wordpress

WordPress是一款全球领先的开源内容管理系统（CMS），以其强大的功能、灵活的扩展性和友好的用户界面而广受欢迎。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://bbs.017121.xyz/post/101.html">
<meta property="og:image" content="https://pic.myla.eu.org/file/29b29c1e2f4b11671ddca.png">
<title>Docker安装wordpress</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>.box-sizing:border-box}body{min-width:200px;max-width:760px;margin:0 auto;padding:1em;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;color:#595959;font-size:16px;line-height:1.8em;background-image:linear-gradient(90deg,rgba(60,10,30,.05) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-all}blockquote{margin-left:0;background-color:#ebf4ff;border-color:#7f9cf5;padding-top:.5rem;padding-bottom:.5rem;color:#667eea}strong{color:#5a67d8}code,a{color:#5a67d8}a{border-color:#667eea}code{background-color:#ebf4ff}blockquote,details,dl,ol,p,pre,table,ul{margin-bottom:1rem}ol{list-style:decimal}ul{list-style:disc}ol,ul{padding-left:2em}h1,h2{border-color:#5a67d8;border-style:solid;border-top-width:0;border-right-width:0;font-weight:500;padding-top:.25rem;padding-bottom:.25rem;padding-left:.75rem}h1,h2{border-bottom:1px solid #eaecef !important;border-left-width:6px}h1,h2,h3,h4,h5,h6{margin-bottom:16px;line-height:1.25}blockquote{padding-top:.5rem;padding-bottom:.5rem;padding-left:1rem;padding-right:1rem;border-left:.25em solid}blockquote>:last-child{margin-bottom:0}blockquote>:first-child{margin-top:0}strong{font-weight:700}strong::before{content:'「'}strong::after{content:'」'}code,a{font-weight:500}code,a{font-size:unset}a{text-decoration:none;border-bottom:1px solid}.footnote-ref{border-width:0}code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}pre>code{font-weight:400;color:unset;line-height:1.6}picture img{border-radius:6px;display:block;margin:10px auto;object-fit:contain;box-shadow:2px 4px 7px #999}img{max-width:100%;display:block;margin:10px auto;object-fit:contain;border-radius:6px;box-shadow:2px 4px 7px #999}picture{display:flex;flex-direction:column;justify-content:center;align-items:center;margin-top:6px;margin-bottom:6px}pre,pre code[class*="language-"]{display:block;overflow-x:auto;padding:0}pre code[class*="language-"]{padding:12px;padding-top:6px}pre::before{content:'';display:block;background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NCIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDU0IDE0Ij4KICA8ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEgMSkiPgogICAgPGNpcmNsZSBjeD0iNiIgY3k9IjYiIHI9IjYiIGZpbGw9IiNGRjVGNTYiIHN0cm9rZT0iI0UwNDQzRSIgc3Ryb2tlLXdpZHRoPSIuNSIvPgogICAgPGNpcmNsZSBjeD0iMjYiIGN5PSI2IiByPSI2IiBmaWxsPSIjRkZCRDJFIiBzdHJva2U9IiNERUExMjMiIHN0cm9rZS13aWR0aD0iLjUiLz4KICAgIDxjaXJjbGUgY3g9IjQ2IiBjeT0iNiIgcj0iNiIgZmlsbD0iIzI3QzkzRiIgc3Ryb2tlPSIjMUFBQjI5IiBzdHJva2Utd2lkdGg9Ii41Ii8+CiAgPC9nPgo8L3N2Zz4K");height:30px;width:100%;margin-bottom:-7px;background-size:40px;background-repeat:no-repeat}.svg-markmap-box{min-height:20rem;width:100%}.footnotes{padding-top:.5rem;padding-bottom:.5rem}code[class*="language-"],pre[class*="language-"]{color:#f8f8f2;background:none;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*="language-"]{padding:1em;margin:.5em 0;overflow:auto;border-radius:6px}:not(pre)>code[class*="language-"],pre[class*="language-"]{background:#272822}:not(pre)>code[class*="language-"]{padding:.1em;border-radius:.3em;white-space:normal}.token.comment,.token.prolog,.token.doctype,.token.cdata{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.property,.token.tag,.token.constant,.token.symbol,.token.deleted{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#a6e22e}.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.function,.token.class-name{color:#e6db74}.token.keyword{color:#66d9ef}.token.regex,.token.important{color:#fd971f}.token.important,.token.bold{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style>



<body>
    <div id="header">
<h1 class="postTitle">Docker安装wordpress</h1>
<div class="title-right">
    <a href="https://bbs.017121.xyz" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/igweek/igweek.github.io/issues/101" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>一、Docker安装wordpress</h1>
<h2>1. 引言</h2>
<h3>1.1 WordPress简介</h3>
<h4>wordpress</h4>
<p>WordPress是一款全球领先的开源内容管理系统（CMS），以其强大的功能、灵活的扩展性和友好的用户界面而广受欢迎。无论是个人博客、企业官网还是电子商务平台，WordPress都能提供稳定可靠的解决方案。它基于PHP语言和MySQL数据库构建，拥有庞大的社区支持和丰富的插件、主题生态系统。</p>
<h3>1.2 Docker与WordPress结合的优势 (强调纯命令行部署的灵活性)</h3>
<p>Docker作为一种轻量级容器化技术，为WordPress的部署带来了革命性的变革。通过Docker，我们可以将WordPress及其所有依赖（如MySQL、Nginx、PHP环境）打包成独立的、可移植的容器，从而实现“一次构建，随处运行”。与传统的部署方式相比，Docker化部署具有以下显著优势：</p>
<ul>
<li><strong>环境隔离</strong>：每个服务（WordPress、MySQL、Nginx）运行在独立的容器中，相互之间互不干扰，避免了环境冲突问题。</li>
<li><strong>部署便捷</strong>：通过简单的<code class="notranslate">docker run</code>命令即可快速启动整个WordPress环境，大大简化了部署流程。</li>
<li><strong>可移植性</strong>：容器化的WordPress应用可以在任何支持Docker的平台上运行，无论是开发、测试还是生产环境，都能保持一致性。</li>
<li><strong>资源高效</strong>：容器共享宿主机的操作系统内核，相比虚拟机更加轻量级，资源利用率更高。</li>
<li><strong>易于管理</strong>：容器的生命周期管理（启动、停止、删除、更新）变得简单明了，方便维护。</li>
<li><strong>纯命令行部署的灵ness</strong>：本手册将重点介绍如何完全通过纯命令行<code class="notranslate">docker run</code>命令来部署WordPress，这使得用户可以更深入地理解每个组件的配置和交互，提供了极高的灵活性和控制力，尤其适合需要精细化控制和自动化脚本部署的场景。</li>
</ul>
<h3>1.3 实验目的</h3>
<p>本实验手册旨在指导读者在CentOS 8操作系统上，使用纯命令行Docker技术，从零开始构建一个包含Nginx反向代理的WordPress网站。通过本手册的学习，您将能够：</p>
<ul>
<li>掌握Docker网络、数据卷等核心概念在实际应用中的配置。</li>
<li>学会使用<code class="notranslate">docker run</code>命令独立启动和管理MySQL、WordPress和Nginx容器。</li>
<li>理解Nginx作为反向代理如何与WordPress容器协同工作。</li>
<li>完成WordPress的首次安装与基本配置。</li>
<li>了解WordPress和MySQL数据持久化与备份的重要性及方法。</li>
<li>掌握常见的故障排除技巧和性能优化建议。</li>
</ul>
<p>通过本实验，您将不仅能够成功部署一个Docker化的WordPress网站，还能对Docker的纯命令行操作有更深入的理解，为后续更复杂的容器化应用部署打下坚实基础。</p>
<h1>2. 准备工作</h1>
<p>在开始使用纯命令行Docker安装WordPress并配置Nginx反向代理之前，确保您的系统环境已正确配置是至关重要的一步。本章节将指导您检查系统要求、验证Docker的安装，并创建必要的项目目录和数据持久化目录，包括Nginx的配置目录。</p>
<h2>2.1 系统要求与Docker环境验证</h2>
<p>本实验手册假设您正在使用 <strong>CentOS 8</strong> 操作系统。为了顺利运行WordPress及其依赖服务（如MySQL和Nginx），您的系统应满足以下基本要求：</p>
<ul>
<li><strong>操作系统</strong>：CentOS 8 (或兼容的RHEL 8发行版)。</li>
<li><strong>内存</strong>：建议至少4GB RAM，以确保Nginx、WordPress和MySQL容器能够稳定运行。</li>
<li><strong>磁盘空间</strong>：建议至少20GB可用磁盘空间，用于存储Docker镜像、容器数据以及WordPress和Nginx文件。</li>
<li><strong>网络连接</strong>：确保系统可以访问互联网，以便拉取Docker镜像。</li>
</ul>
<p>此外，您需要确保系统上已正确安装并配置了Docker Engine。如果您尚未安装，请参考上一份实验手册《Docker实验手册 (CentOS 8)》中的“Docker安装与配置”章节进行安装和配置，特别是要确保配置了国内镜像加速，以提高镜像拉取速度。</p>
<p>您可以通过以下命令验证Docker Engine的安装情况：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker version</pre></div>
<p>如果Docker Engine已正确安装，此命令将显示Docker客户端和服务器的版本信息。请确保服务器版本（Server Version）存在。</p>
<h2>2.2 创建项目目录和数据持久化目录</h2>
<p>为了更好地组织WordPress项目文件和Docker容器的数据，建议为您的WordPress安装创建一个独立的目录。这个目录将包含用于数据持久化的子目录，以及Nginx的配置文件目录。</p>
<ol>
<li><strong>创建主项目目录</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir <span class="pl-k">~</span>/wordpress-nginx-docker-run
<span class="pl-c1">cd</span> <span class="pl-k">~</span>/wordpress-nginx-docker-run</pre></div>
<pre class="notranslate"><code class="notranslate">此命令将在您的用户主目录下创建一个名为`wordpress-nginx-docker-run`的目录，并进入该目录。所有后续的操作都将在此目录下进行。
</code></pre>
<ol start="2">
<li>
<p><strong>创建数据持久化目录</strong>：</p>
<p>为了确保WordPress和MySQL的数据在容器重建后不会丢失，我们将使用数据卷进行持久化。我们将创建两个用于绑定挂载的目录，分别用于存储WordPress的文件和MySQL的数据库数据。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir ./wordpress_data
mkdir ./db_data</pre></div>
<pre class="notranslate"><code class="notranslate">*   `./wordpress_data`：将用于存储WordPress的程序文件、主题、插件和上传内容。
*   `./db_data`：将用于存储MySQL数据库的数据文件。
</code></pre>
<ol start="3">
<li>
<p><strong>创建Nginx配置文件目录</strong>：</p>
<p>Nginx容器需要一个配置文件来定义反向代理规则。我们将创建一个目录来存放这个配置文件。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir ./nginx_conf</pre></div>
<pre class="notranslate"><code class="notranslate">`./nginx_conf`：将用于存放Nginx的配置文件，例如`nginx.conf`或`default.conf`。
</code></pre>
<p>完成以上准备工作后，您的系统已为使用纯命令行部署WordPress和Nginx反向代理做好了充分准备。接下来，我们将开始使用<code class="notranslate">docker run</code>命令来启动MySQL数据库容器。</p>
<h1>3. 纯命令行启动MySQL容器</h1>
<p>在部署WordPress之前，我们需要先启动一个MySQL数据库容器。WordPress将使用这个数据库来存储其所有数据。本章节将指导您如何使用<code class="notranslate">docker run</code>命令创建并启动一个MySQL容器，并配置其网络和数据持久化。</p>
<h2>3.1 创建Docker网络</h2>
<p>为了让WordPress容器和MySQL容器能够相互通信，我们需要创建一个自定义的Docker网络。这样，容器之间可以通过服务名称而不是IP地址进行通信，增加了灵活性和可维护性。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker network create wordpress-network</pre></div>
<p>此命令将创建一个名为<code class="notranslate">wordpress-network</code>的桥接网络。后续启动WordPress、Nginx和MySQL容器时，我们将它们连接到这个网络。</p>
<h2>3.2 启动MySQL容器</h2>
<p>现在，我们将使用<code class="notranslate">docker run</code>命令启动MySQL容器。这个命令会包含数据卷挂载、环境变量设置和网络连接等关键配置。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  --name mysql-db \
  --network wordpress-network \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/db_data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=root_password \
  -e MYSQL_DATABASE=wordpress_db \
  -e MYSQL_USER=wordpress \
  -e MYSQL_PASSWORD=wordpress_password \
  -d mysql:8.0</pre></div>
<h3>3.2.1 命令参数解析</h3>
<ul>
<li><code class="notranslate">--name mysql-db</code>：为MySQL容器指定一个名称为<code class="notranslate">mysql-db</code>。这个名称将在Docker网络中作为主机名，供其他容器（如WordPress）访问。</li>
<li><code class="notranslate">--network wordpress-network</code>：将MySQL容器连接到我们之前创建的<code class="notranslate">wordpress-network</code>网络。</li>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/db_data:/var/lib/mysql</code>：将宿主机上<code class="notranslate">~/wordpress-nginx-docker-run/db_data</code>目录绑定挂载到容器内部的<code class="notranslate">/var/lib/mysql</code>路径。这是MySQL存储数据的地方，用于持久化数据库内容。这样即使容器被删除，数据也不会丢失。</li>
<li><code class="notranslate">-e MYSQL_ROOT_PASSWORD=root_password</code>：设置MySQL的root用户密码为<code class="notranslate">root_password</code>。请在实际生产环境中替换为强密码。</li>
<li><code class="notranslate">-e MYSQL_DATABASE=wordpress_db</code>：在容器启动时创建一个名为<code class="notranslate">wordpress_db</code>的数据库。</li>
<li><code class="notranslate">-e MYSQL_USER=wordpress</code>：创建一个名为<code class="notranslate">wordpress</code>的数据库用户。</li>
<li><code class="notranslate">-e MYSQL_PASSWORD=wordpress_password</code>：设置<code class="notranslate">wordpress</code>用户的密码为<code class="notranslate">wordpress_password</code>。请在实际生产环境中替换为强密码。</li>
<li><code class="notranslate">-d mysql:8.0</code>：指定使用<code class="notranslate">mysql:8.0</code>镜像启动容器，并在后台（detached mode）运行。</li>
</ul>
<h2>3.3 验证MySQL容器状态</h2>
<p>容器启动后，您可以使用以下命令验证MySQL容器是否正常运行：</p>
<ol>
<li><strong>查看运行中的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps</pre></div>
<p>您应该能看到名为<code class="notranslate">mysql-db</code>的容器处于<code class="notranslate">Up</code>状态。</p>
<ol start="2">
<li><strong>查看容器日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs mysql-db</pre></div>
<p>检查日志输出，确保没有错误信息，并且MySQL服务已成功启动。您可能会看到类似“<code class="notranslate">X.X.X MySQL Community Server - GPL</code>”的启动信息。</p>
<ol start="3">
<li><strong>进入MySQL容器验证数据库</strong>：</li>
</ol>
<p>您可以进入MySQL容器内部，使用MySQL客户端验证数据库和用户是否已成功创建。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it mysql-db mysql -u root -proot_password</pre></div>
<p>进入MySQL命令行后，可以执行以下命令验证：</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">SHOW DATABASES;
<span class="pl-k">SELECT</span> User, Host <span class="pl-k">FROM</span> <span class="pl-c1">mysql</span>.<span class="pl-c1">user</span>;
EXIT;</pre></div>
<p>您应该能看到<code class="notranslate">wordpress_db</code>数据库和<code class="notranslate">wordpress</code>用户。验证完成后，输入<code class="notranslate">exit</code>退出MySQL客户端。</p>
<p>至此，MySQL数据库容器已成功启动并配置完成，为WordPress的部署奠定了基础。</p>
<h1>5. 纯命令行启动Nginx反向代理容器</h1>
<p>为了更好地管理流量、提供SSL/TLS加密（HTTPS）以及实现更灵活的部署，我们通常会在WordPress容器前放置一个Nginx反向代理。本章节将指导您如何创建Nginx配置文件，并使用<code class="notranslate">docker run</code>命令启动Nginx容器作为WordPress的反向代理。</p>
<h2>5.1 创建Nginx配置文件</h2>
<p>Nginx容器需要一个配置文件来定义其作为反向代理的行为。我们将创建一个名为<code class="notranslate">default.conf</code>的文件，并将其放置在之前创建的<code class="notranslate">~/wordpress-nginx-docker-run/nginx_conf</code>目录下。</p>
<p>首先，进入Nginx配置目录：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c1">cd</span> <span class="pl-k">~</span>/wordpress-nginx-docker-run/nginx_conf</pre></div>
<p>然后，使用文本编辑器（如<code class="notranslate">vi</code>或<code class="notranslate">nano</code>）创建并编辑<code class="notranslate">default.conf</code>文件：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">vi default.conf</pre></div>
<p>将以下内容复制粘贴到<code class="notranslate">default.conf</code>文件中：</p>
<div class="highlight highlight-source-nginx"><pre class="notranslate"><span class="pl-c1">server</span> <span class="pl-c1">{</span>
    <span class="pl-c1">listen</span> <span class="pl-c1">80</span><span class="pl-c1">;</span>
    <span class="pl-c1">server_name</span> localhost &lt;您的服务器IP地址或域名&gt;<span class="pl-c1">;</span>

    <span class="pl-c1">location</span> / <span class="pl-c1">{</span>
        <span class="pl-c1">proxy_pass</span> <span class="pl-c1">http</span>://wordpress-app:<span class="pl-c1">80</span><span class="pl-c1">;</span>
        <span class="pl-c1">proxy_set_header</span> Host <span class="pl-v">$host</span><span class="pl-c1">;</span>
        <span class="pl-c1">proxy_set_header</span> X-Real-IP <span class="pl-v">$remote_addr</span><span class="pl-c1">;</span>
        <span class="pl-c1">proxy_set_header</span> X-Forwarded-For <span class="pl-v">$proxy_add_x_forwarded_for</span><span class="pl-c1">;</span>
        <span class="pl-c1">proxy_set_header</span> X-Forwarded-Proto <span class="pl-v">$scheme</span><span class="pl-c1">;</span>
    <span class="pl-c1">}</span>
<span class="pl-c1">}</span></pre></div>
<h3>5.1.1 配置文件解析</h3>
<ul>
<li><code class="notranslate">listen 80;</code>：Nginx监听宿主机的80端口，接收HTTP请求。</li>
<li><code class="notranslate">server_name localhost &lt;您的服务器IP地址或域名&gt;;</code>：定义Nginx服务器的名称。请将<code class="notranslate">&lt;您的服务器IP地址或域名&gt;</code>替换为实际的IP地址或域名，例如<code class="notranslate">example.com</code>。</li>
<li><code class="notranslate">location /</code>：匹配所有请求。</li>
<li><code class="notranslate">proxy_pass http://wordpress-app:80;</code>：这是反向代理的核心指令。它将所有请求转发到<code class="notranslate">wordpress-app</code>容器的80端口。<code class="notranslate">wordpress-app</code>是我们在Docker网络中为WordPress容器指定的名称。</li>
<li><code class="notranslate">proxy_set_header ...;</code>：这些指令用于设置HTTP请求头，确保WordPress能够正确获取客户端的真实IP地址、主机名和协议信息。这对于WordPress的正常运行和日志记录非常重要。</li>
</ul>
<p>保存并关闭<code class="notranslate">default.conf</code>文件。</p>
<h2>5.2 启动Nginx容器</h2>
<p>现在，我们将使用<code class="notranslate">docker run</code>命令启动Nginx容器。这个命令会包含端口映射、配置文件挂载和网络连接等关键配置。</p>
<p>首先，回到主项目目录：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c1">cd</span> ..</pre></div>
<p>然后执行以下<code class="notranslate">docker run</code>命令：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  --name nginx-proxy \
  --network wordpress-network \
  -p 80:80 \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro \
  -d nginx:latest</pre></div>
<h3>5.2.1 命令参数解析</h3>
<ul>
<li><code class="notranslate">--name nginx-proxy</code>：为Nginx容器指定一个名称为<code class="notranslate">nginx-proxy</code>。</li>
<li><code class="notranslate">--network wordpress-network</code>：将Nginx容器连接到我们之前创建的<code class="notranslate">wordpress-network</code>网络。这使得Nginx容器可以通过服务名称<code class="notranslate">wordpress-app</code>访问WordPress容器。</li>
<li><code class="notranslate">-p 80:80</code>：将宿主机的80端口映射到Nginx容器的80端口。这样，外部流量将首先到达Nginx，再由Nginx转发给WordPress。</li>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro</code>：将宿主机上我们刚刚创建的<code class="notranslate">default.conf</code>文件绑定挂载到Nginx容器内部的<code class="notranslate">/etc/nginx/conf.d/default.conf</code>路径。<code class="notranslate">:ro</code>表示只读，确保容器不会修改此配置文件。</li>
<li><code class="notranslate">-d nginx:latest</code>：指定使用<code class="notranslate">nginx:latest</code>镜像启动容器，并在后台（detached mode）运行。</li>
</ul>
<h2>5.3 验证Nginx容器状态</h2>
<p>容器启动后，您可以使用以下命令验证Nginx容器是否正常运行：</p>
<ol>
<li><strong>查看运行中的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps</pre></div>
<p>您应该能看到名为<code class="notranslate">nginx-proxy</code>的容器处于<code class="notranslate">Up</code>状态。</p>
<ol start="2">
<li><strong>查看容器日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs nginx-proxy</pre></div>
<p>检查日志输出，确保没有错误信息，并且Nginx服务已成功启动。您可能会看到类似“<code class="notranslate">nginx: [emerg] ...</code>”或“<code class="notranslate">nginx: [warn] ...</code>”的警告或错误信息，需要根据具体情况进行排查。正常启动应显示Nginx的启动信息。</p>
<p>至此，Nginx反向代理容器已成功启动并配置完成，它将作为WordPress网站的入口。接下来，我们将启动WordPress容器，并将其连接到Nginx代理的后端。</p>
<h1>6. 纯命令行启动WordPress容器</h1>
<p>在MySQL容器成功运行并配置好数据库，以及Nginx反向代理容器准备就绪后，我们现在可以启动WordPress容器。本章节将指导您如何使用<code class="notranslate">docker run</code>命令创建并启动一个WordPress容器，并配置其与MySQL容器的连接、数据持久化和网络连接。<strong>请注意，WordPress容器的端口将不会直接映射到宿主机，而是通过Nginx反向代理进行访问。</strong></p>
<h2>6.1 启动WordPress容器</h2>
<p>在您之前创建的<code class="notranslate">~/wordpress-nginx-docker-run</code>目录下，执行以下<code class="notranslate">docker run</code>命令来启动WordPress容器：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  --name wordpress-app \
  --network wordpress-network \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data:/var/www/html \
  -e WORDPRESS_DB_HOST=mysql-db:3306 \
  -e WORDPRESS_DB_USER=wordpress \
  -e WORDPRESS_DB_PASSWORD=wordpress_password \
  -e WORDPRESS_DB_NAME=wordpress_db \
  -d wordpress:latest</pre></div>
<h3>6.1.1 命令参数解析</h3>
<ul>
<li><code class="notranslate">--name wordpress-app</code>：为WordPress容器指定一个名称为<code class="notranslate">wordpress-app</code>。</li>
<li><code class="notranslate">--network wordpress-network</code>：将WordPress容器连接到我们之前创建的<code class="notranslate">wordpress-network</code>网络。这使得WordPress容器可以通过<code class="notranslate">mysql-db</code>这个服务名称访问MySQL容器，同时Nginx容器也可以通过此网络访问WordPress容器。</li>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/wordpress_data:/var/www/html</code>：将宿主机上<code class="notranslate">~/wordpress-nginx-docker-run/wordpress_data</code>目录绑定挂载到WordPress容器内部的<code class="notranslate">/var/www/html</code>路径。这是WordPress的安装路径，用于持久化WordPress的核心文件、主题、插件和上传内容。这样即使容器被删除，数据也不会丢失。</li>
<li><code class="notranslate">-e WORDPRESS_DB_HOST=mysql-db:3306</code>：指定WordPress连接数据库的主机和端口。<code class="notranslate">mysql-db</code>是MySQL容器的名称（在<code class="notranslate">wordpress-network</code>网络中作为主机名），<code class="notranslate">3306</code>是MySQL的默认端口。<strong>注意：这里必须使用MySQL容器的名称作为主机名，而不是<code class="notranslate">localhost</code>或宿主机IP。</strong></li>
<li><code class="notranslate">-e WORDPRESS_DB_USER=wordpress</code>：WordPress连接数据库的用户名，必须与MySQL容器中创建的用户一致。</li>
<li><code class="notranslate">-e WORDPRESS_DB_PASSWORD=wordpress_password</code>：WordPress连接数据库的密码，必须与MySQL容器中创建的密码一致。</li>
<li><code class="notranslate">-e WORDPRESS_DB_NAME=wordpress_db</code>：WordPress使用的数据库名称，必须与MySQL容器中创建的数据库名称一致。</li>
<li><code class="notranslate">-d wordpress:latest</code>：指定使用<code class="notranslate">wordpress:latest</code>镜像启动容器，并在后台（detached mode）运行。</li>
</ul>
<p><strong>重要提示</strong>：与之前直接暴露WordPress端口不同，这里我们没有使用<code class="notranslate">-p</code>参数将WordPress容器的80端口映射到宿主机。这是因为Nginx反向代理容器已经占用了宿主机的80端口，并负责将外部请求转发到WordPress容器内部的80端口。</p>
<h2>6.2 验证WordPress容器状态</h2>
<p>容器启动后，您可以使用以下命令验证WordPress容器是否正常运行：</p>
<ol>
<li><strong>查看运行中的容器</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker ps</pre></div>
<p>您应该能看到名为<code class="notranslate">wordpress-app</code>的容器处于<code class="notranslate">Up</code>状态。</p>
<ol start="2">
<li><strong>查看容器日志</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs wordpress-app</pre></div>
<p>检查日志输出，确保没有错误信息，并且WordPress服务已成功启动。您可能会看到类似“<code class="notranslate">Apache/2.4.58 (Debian) PHP/8.2.13 Development Server (http://localhost:80) configured -- resuming normal operations</code>”的启动信息，或者关于数据库连接成功的提示。</p>
<p>至此，WordPress容器已成功启动并连接到MySQL数据库，并通过Docker网络等待Nginx反向代理的请求。接下来，您将通过Nginx访问WordPress进行首次安装配置。</p>
<h1>7. WordPress配置与访问</h1>
<p>在Nginx反向代理容器和WordPress容器都成功启动后，您现在可以通过Nginx的入口访问WordPress进行首次安装配置。本章节将详细指导这些操作。</p>
<h2>7.1 首次访问WordPress进行安装配置</h2>
<ol>
<li>
<p><strong>打开Web浏览器</strong>：</p>
<p>在您的宿主机上打开任意Web浏览器（如Chrome, Firefox等）。</p>
</li>
<li>
<p><strong>访问WordPress安装页面</strong>：</p>
<p>在浏览器地址栏输入您的宿主机IP地址或您在Nginx配置中设置的域名。由于Nginx监听宿主机的80端口，因此直接访问即可：</p>
</li>
</ol>
<pre class="notranslate"><code class="notranslate">http://localhost
</code></pre>
<pre class="notranslate"><code class="notranslate">或者，如果您是在远程服务器上操作，请替换`localhost`为您的服务器IP地址或域名：
</code></pre>
<pre class="notranslate"><code class="notranslate">http://&lt;您的服务器IP地址或域名&gt;
</code></pre>
<ol start="3">
<li>
<p><strong>选择语言</strong>：</p>
<p>首次访问时，WordPress会提示您选择安装语言。选择您偏好的语言（例如“简体中文”），然后点击“继续”。</p>
</li>
<li>
<p><strong>欢迎页面</strong>：</p>
<p>您将看到WordPress的欢迎页面，提示您需要数据库信息。点击“现在就开始！”。</p>
</li>
<li>
<p><strong>数据库连接信息</strong>：</p>
<p>在数据库连接信息页面，填写以下内容：</p>
<ul>
<li><strong>数据库名</strong>：<code class="notranslate">wordpress_db</code> (与<code class="notranslate">docker run</code>命令中<code class="notranslate">MYSQL_DATABASE</code>一致)</li>
<li><strong>用户名</strong>：<code class="notranslate">wordpress</code> (与<code class="notranslate">docker run</code>命令中<code class="notranslate">MYSQL_USER</code>一致)</li>
<li><strong>密码</strong>：<code class="notranslate">wordpress_password</code> (与<code class="notranslate">docker run</code>命令中<code class="notranslate">MYSQL_PASSWORD</code>一致)</li>
<li><strong>数据库主机</strong>：<code class="notranslate">mysql-db:3306</code> (这是MySQL容器的名称和端口，在Docker网络中作为主机名)</li>
<li><strong>表前缀</strong>：<code class="notranslate">wp_</code> (保持默认或自定义，不影响功能)</li>
</ul>
<p>填写完毕后，点击“提交”。</p>
</li>
<li>
<p><strong>运行安装</strong>：</p>
<p>如果数据库连接成功，您将看到“运行安装”页面。点击“运行安装”。</p>
</li>
<li>
<p><strong>站点信息</strong>：</p>
<p>填写您的站点信息：</p>
<ul>
<li><strong>站点标题</strong>：您的网站名称 (例如：<code class="notranslate">我的Docker Nginx WordPress博客</code>)</li>
<li><strong>用户名</strong>：WordPress后台登录用户名 (例如：<code class="notranslate">admin</code>)</li>
<li><strong>密码</strong>：WordPress后台登录密码 (请设置一个强密码并牢记)</li>
<li><strong>您的电子邮件</strong>：用于接收通知和密码重置 (例如：<code class="notranslate">your_email@example.com</code>)</li>
<li><strong>搜索引擎可见性</strong>：根据需要勾选或取消勾选“建议搜索引擎不索引本站点”（通常在开发阶段勾选，生产环境取消勾选）。</li>
</ul>
<p>填写完毕后，点击“安装WordPress”。</p>
</li>
<li>
<p><strong>安装成功</strong>：</p>
<p>安装成功后，您将看到“成功！”页面。点击“登录”即可进入WordPress后台管理界面。</p>
</li>
</ol>
<p>至此，您的WordPress网站已通过纯命令行Docker和Nginx反向代理成功安装并运行。</p>
<h2>7.2 (可选) 通过MySQL客户端连接数据库</h2>
<p>如果您需要直接管理MySQL数据库，可以通过宿主机上的MySQL客户端或Docker容器内的MySQL客户端连接到<code class="notranslate">mysql-db</code>容器。</p>
<ol>
<li>
<p><strong>从宿主机连接 (需要安装MySQL客户端)</strong>：</p>
<p><strong>注意</strong>：在我们的配置中，MySQL容器的3306端口并未映射到宿主机，因此无法从宿主机直接访问。更推荐的方式是进入MySQL容器内部进行操作。</p>
</li>
<li>
<p><strong>进入MySQL容器内部连接</strong>：</p>
<p>这是更推荐的方式，可以直接在MySQL容器内部使用其自带的客户端。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it mysql-db mysql -u wordpress -pwordpress_password wordpress_db</pre></div>
<pre class="notranslate"><code class="notranslate">进入MySQL命令行后，您可以执行SQL命令来管理数据库，例如：
</code></pre>
<div class="highlight highlight-source-sql"><pre class="notranslate">SHOW TABLES;
<span class="pl-k">SELECT</span> User, Host <span class="pl-k">FROM</span> <span class="pl-c1">mysql</span>.<span class="pl-c1">user</span>;
EXIT;</pre></div>
<pre class="notranslate"><code class="notranslate">您应该能看到`wordpress_db`数据库和`wordpress`用户。验证完成后，输入`exit`退出MySQL客户端。
</code></pre>
<p>通过本章节，您已经完成了WordPress的首次安装和配置，并学会了如何（可选地）通过MySQL客户端管理其底层数据库。</p>
<h1>8. 数据持久化与备份</h1>
<p>对于任何生产环境的应用程序，数据持久化和备份都是至关重要的环节。WordPress作为一个内容管理系统，其核心数据（文章、页面、用户、配置等）存储在MySQL数据库中，而其文件数据（主题、插件、上传的媒体文件等）则存储在文件系统中。Nginx作为反向代理，其配置文件也需要持久化。本章节将回顾我们在<code class="notranslate">docker run</code>命令中如何实现数据持久化，并简要介绍备份策略。</p>
<h2>8.1 数据持久化的重要性</h2>
<p>Docker容器的设计理念是轻量级和无状态的。这意味着容器在停止或删除后，其内部写入的所有数据都会丢失。对于WordPress、MySQL和Nginx这类需要存储数据或配置的应用，如果数据不进行持久化，那么每次容器重建或更新都会导致数据丢失或配置重置，这是不可接受的。</p>
<p>Docker提供了**数据卷（Volumes）**机制来解决这个问题。数据卷是宿主机文件系统中的一个特殊目录，它可以被挂载到容器内部的指定路径。数据卷独立于容器的生命周期，即使容器被删除，数据卷中的数据依然存在，从而实现了数据的持久化存储。</p>
<h2>8.2 WordPress、MySQL和Nginx数据卷配置回顾</h2>
<p>在之前的<code class="notranslate">docker run</code>命令中，我们通过<code class="notranslate">-v</code>参数为WordPress、MySQL和Nginx服务配置了数据持久化：</p>
<h3>8.2.1 MySQL容器的数据持久化</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/db_data:/var/lib/mysql \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  mysql:8.0</pre></div>
<ul>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/db_data:/var/lib/mysql</code>：这行配置将宿主机上<code class="notranslate">~/wordpress-nginx-docker-run/db_data</code>目录（我们在准备工作中创建的）绑定挂载到MySQL容器内部的<code class="notranslate">/var/lib/mysql</code>路径。MySQL数据库的所有数据文件（包括<code class="notranslate">wordpress_db</code>数据库中的所有表和数据）都将存储在这个宿主机目录中。这确保了数据库数据在MySQL容器被删除或更新后不会丢失。</li>
</ul>
<h3>8.2.2 WordPress容器的数据持久化</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data:/var/www/html \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  wordpress:latest</pre></div>
<ul>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/wordpress_data:/var/www/html</code>：这行配置将宿主机上<code class="notranslate">~/wordpress-nginx-docker-run/wordpress_data</code>目录绑定挂载到WordPress容器内部的<code class="notranslate">/var/www/html</code>路径。WordPress的所有程序文件、主题、插件、上传的媒体文件等都将存储在这个宿主机目录中。这意味着您可以直接在宿主机上访问和管理这些文件，并且在WordPress容器被删除或更新后，这些数据依然会保留。</li>
</ul>
<h3>8.2.3 Nginx容器的配置文件持久化</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro \
  <span class="pl-c"><span class="pl-c">#</span> ... 其他参数 ...</span>
  nginx:latest</pre></div>
<ul>
<li><code class="notranslate">-v ~/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro</code>：这行配置将宿主机上我们创建的<code class="notranslate">default.conf</code>文件绑定挂载到Nginx容器内部的<code class="notranslate">/etc/nginx/conf.d/default.conf</code>路径。<code class="notranslate">:ro</code>表示只读，确保容器不会修改此配置文件。通过这种方式，Nginx的配置得以持久化，即使Nginx容器被删除或重建，其配置也能保持一致。</li>
</ul>
<p>通过这种方式，我们确保了WordPress网站的所有关键数据和Nginx配置都存储在宿主机的文件系统中，从而实现了数据的持久化。</p>
<h2>8.3 简要备份策略</h2>
<p>尽管数据已经持久化，但为了应对宿主机故障、误操作或数据损坏等情况，定期备份这些持久化数据仍然是必不可少的。以下是一些简单的备份策略：</p>
<ol>
<li>
<p><strong>备份WordPress文件数据</strong>：</p>
<p>由于WordPress的文件数据存储在宿主机的<code class="notranslate">~/wordpress-nginx-docker-run/wordpress_data</code>目录下，您只需定期备份这个目录即可。可以使用<code class="notranslate">tar</code>命令进行打包压缩，并将其存储到安全的位置（例如，远程存储、云存储或另一个物理磁盘）。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 停止WordPress容器以确保文件一致性（可选，但推荐）</span>
docker stop wordpress-app

<span class="pl-c"><span class="pl-c">#</span> 备份WordPress文件</span>
tar -czvf wordpress_files_backup_<span class="pl-s"><span class="pl-pds">$(</span>date +%Y%m%d<span class="pl-pds">)</span></span>.tar.gz <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data

<span class="pl-c"><span class="pl-c">#</span> 启动WordPress容器</span>
docker start wordpress-app</pre></div>
<ol start="2">
<li>
<p><strong>备份MySQL数据库数据</strong>：</p>
<p>备份MySQL数据库的最佳实践是使用<code class="notranslate">mysqldump</code>工具。您可以在MySQL容器内部执行<code class="notranslate">mysqldump</code>命令，将数据库导出为SQL文件，然后将该文件复制到宿主机进行备份。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> mysql-db mysqldump -u wordpress -pwordpress_password wordpress_db <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/wordpress-nginx-docker-run/db_data/wordpress_db_backup_<span class="pl-s"><span class="pl-pds">$(</span>date +%Y%m%d<span class="pl-pds">)</span></span>.sql

<span class="pl-c"><span class="pl-c">#</span> 此时，备份文件已在宿主机的 ~/wordpress-nginx-docker-run/db_data 目录下</span>
<span class="pl-c"><span class="pl-c">#</span> 您可以进一步将此SQL文件移动或复制到其他备份位置</span></pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：上述`mysqldump`命令中的`wordpress`是数据库用户名，`wordpress_password`是密码，`wordpress_db`是数据库名，这些都应与`docker run`命令中配置的一致。备份文件被直接写入到`db_data`目录，因此它会持久化在宿主机上。
</code></pre>
<ol start="3">
<li>
<p><strong>备份Nginx配置文件</strong>：</p>
<p>Nginx的配置文件<code class="notranslate">default.conf</code>已经存储在宿主机的<code class="notranslate">~/wordpress-nginx-docker-run/nginx_conf</code>目录下，因此您只需确保这个目录被包含在您的宿主机备份策略中即可。</p>
</li>
<li>
<p><strong>自动化备份</strong>：</p>
<p>为了确保备份的及时性和可靠性，建议将上述备份命令编写成脚本，并结合<code class="notranslate">cron</code>等工具进行自动化调度，实现定期自动备份。</p>
</li>
</ol>
<p>通过实施有效的数据持久化和备份策略，您可以大大提高WordPress网站的健壮性和数据安全性，确保在发生意外情况时能够迅速恢复服务。</p>
<h1>9. 故障排除与优化</h1>
<p>在使用纯命令行Docker部署WordPress并配置Nginx反向代理时，可能会遇到各种问题，例如容器无法启动、端口冲突、数据库连接失败或Nginx代理配置错误等。本章节将提供一些常见的故障排除方法和优化建议，帮助您确保WordPress网站的稳定运行和良好性能。</p>
<h2>9.1 常见问题及解决方案</h2>
<h3>9.1.1 容器无法启动</h3>
<p>当您执行 <code class="notranslate">docker run</code> 命令后，如果发现容器没有成功启动，可以按照以下步骤进行排查：</p>
<ol>
<li>
<p><strong>查看容器日志</strong>：</p>
<p>这是排查容器启动问题的首要步骤。通过查看容器的日志输出，通常可以找到启动失败的具体原因。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs <span class="pl-k">&lt;</span>容器名称或ID<span class="pl-k">&gt;</span></pre></div>
<pre class="notranslate"><code class="notranslate">例如，查看MySQL容器的日志：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs mysql-db</pre></div>
<pre class="notranslate"><code class="notranslate">查看WordPress容器的日志：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs wordpress-app</pre></div>
<pre class="notranslate"><code class="notranslate">查看Nginx容器的日志：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs nginx-proxy</pre></div>
<pre class="notranslate"><code class="notranslate">日志中可能会显示配置错误、依赖缺失或权限问题等信息。
</code></pre>
<ol start="2">
<li>
<p><strong>检查端口冲突</strong>：</p>
<p>如果日志显示端口被占用，可能是宿主机上的其他进程占用了Nginx所需的端口（默认为80）。</p>
<ul>
<li><strong>识别占用端口的进程</strong>：</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo netstat -tulnp <span class="pl-k">|</span> grep :80</pre></div>
<pre class="notranslate"><code class="notranslate">*   **解决方案**：
    *   停止占用端口的进程。
    *   修改Nginx容器的端口映射，例如将Nginx的80端口映射到宿主机的8080端口：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker run \
  --name nginx-proxy \
  --network wordpress-network \
  -p 8080:80 \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro \
  -d nginx:latest</pre></div>
<pre class="notranslate"><code class="notranslate">    修改后，需要先停止并删除旧容器，然后重新启动新容器：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker stop nginx-proxy
docker rm nginx-proxy
<span class="pl-c"><span class="pl-c">#</span> 重新执行修改后的 docker run 命令</span></pre></div>
<h3>9.1.2 数据库连接问题</h3>
<p>WordPress网站显示“Error establishing a database connection”（建立数据库连接错误）是常见问题。这通常是由于WordPress容器无法连接到MySQL数据库容器造成的。</p>
<ol>
<li>
<p><strong>检查环境变量</strong>：</p>
<p>确保WordPress容器启动命令中的数据库连接环境变量与MySQL容器中创建的数据库信息完全一致。</p>
<ul>
<li><code class="notranslate">WORDPRESS_DB_HOST</code>：必须是MySQL容器的名称，即<code class="notranslate">mysql-db</code>，并包含端口<code class="notranslate">mysql-db:3306</code>。</li>
<li><code class="notranslate">WORDPRESS_DB_USER</code>：必须与<code class="notranslate">MYSQL_USER</code>一致。</li>
<li><code class="notranslate">WORDPRESS_DB_PASSWORD</code>：必须与<code class="notranslate">MYSQL_PASSWORD</code>一致。</li>
<li><code class="notranslate">WORDPRESS_DB_NAME</code>：必须与<code class="notranslate">MYSQL_DATABASE</code>一致。</li>
</ul>
</li>
<li>
<p><strong>检查网络连接</strong>：</p>
<p>确保<code class="notranslate">wordpress-app</code>和<code class="notranslate">mysql-db</code>容器都连接到同一个Docker网络（例如<code class="notranslate">wordpress-network</code>）。您可以通过进入WordPress容器并尝试ping数据库服务来验证网络连通性：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it wordpress-app bash
ping mysql-db
<span class="pl-c1">exit</span></pre></div>
<pre class="notranslate"><code class="notranslate">如果`ping mysql-db`失败，则表示网络配置有问题。请检查两个容器是否都使用了`--network wordpress-network`参数。
</code></pre>
<ol start="3">
<li>
<p><strong>检查MySQL服务状态</strong>：</p>
<p>确保MySQL容器正在运行且没有错误。查看<code class="notranslate">mysql-db</code>容器的日志：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs mysql-db</pre></div>
<pre class="notranslate"><code class="notranslate">如果MySQL服务启动失败，WordPress自然无法连接。
</code></pre>
<h3>9.1.3 WordPress权限问题</h3>
<p>有时WordPress在安装主题、插件或上传媒体文件时可能会遇到权限问题。</p>
<ol>
<li>
<p><strong>检查数据卷权限</strong>：</p>
<p>确保宿主机上<code class="notranslate">~/wordpress-nginx-docker-run/wordpress_data</code>目录的权限允许WordPress容器内的用户写入。WordPress容器通常以<code class="notranslate">www-data</code>用户运行。</p>
<ul>
<li><strong>解决方案</strong>：更改宿主机上<code class="notranslate">wordpress_data</code>目录的所有者为Docker容器内WordPress进程的用户ID（通常是33，对应<code class="notranslate">www-data</code>用户），或者给予更宽松的权限（不推荐在生产环境使用）。</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo chown -R 33:33 <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data
<span class="pl-c"><span class="pl-c">#</span> 或者，如果不知道确切UID/GID，可以尝试更宽松的权限（生产环境不推荐）</span>
sudo chmod -R 777 <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data</pre></div>
<h3>9.1.4 Nginx反向代理问题</h3>
<p>如果Nginx容器正常运行，但无法通过浏览器访问WordPress，或者出现“502 Bad Gateway”等错误，可能是Nginx配置或与WordPress容器的连接问题。</p>
<ol>
<li>
<p><strong>检查Nginx配置</strong>：</p>
<p>确保<code class="notranslate">~/wordpress-nginx-docker-run/nginx_conf/default.conf</code>文件中的<code class="notranslate">proxy_pass</code>指向正确的WordPress容器服务名和端口（<code class="notranslate">http://wordpress-app:80</code>）。</p>
</li>
<li>
<p><strong>检查Nginx容器日志</strong>：</p>
<p>查看Nginx容器的日志，通常会显示代理失败的具体原因。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker logs nginx-proxy</pre></div>
<ol start="3">
<li>
<p><strong>检查WordPress容器是否可达</strong>：</p>
<p>进入Nginx容器内部，尝试ping WordPress容器的服务名，确保网络连通性。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it nginx-proxy bash
ping wordpress-app
<span class="pl-c1">exit</span></pre></div>
<pre class="notranslate"><code class="notranslate">如果ping失败，检查两个容器是否都连接到`wordpress-network`。
</code></pre>
<h2>9.2 性能优化建议</h2>
<p>为了提高Docker化WordPress网站的性能和响应速度，可以考虑以下优化措施：</p>
<ol>
<li>
<p><strong>使用高性能数据卷</strong>：</p>
<p>对于生产环境，建议将<code class="notranslate">wordpress_data</code>和<code class="notranslate">db_data</code>目录放置在SSD硬盘上，以提高文件I/O和数据库读写性能。</p>
</li>
<li>
<p><strong>配置WordPress缓存插件</strong>：</p>
<p>安装并配置WordPress缓存插件（如WP Super Cache, W3 Total Cache, LiteSpeed Cache等），可以显著减少数据库查询和页面生成时间，提高网站加载速度。</p>
</li>
<li>
<p><strong>优化MySQL配置</strong>：</p>
<p>根据您的服务器资源和WordPress网站的负载情况，调整MySQL容器的配置参数（例如<code class="notranslate">innodb_buffer_pool_size</code>），以优化数据库性能。这可以通过在<code class="notranslate">docker run</code>命令中添加<code class="notranslate">--mysql-config-file</code>参数或挂载自定义的<code class="notranslate">my.cnf</code>文件来实现。</p>
</li>
<li>
<p><strong>使用CDN</strong>：</p>
<p>对于静态资源（图片、CSS、JavaScript），使用内容分发网络（CDN）可以加快全球用户的访问速度，并减轻服务器负载。</p>
</li>
<li>
<p><strong>定期清理Docker资源</strong>：</p>
<p>定期清理不再使用的Docker镜像、容器和数据卷，可以释放磁盘空间，保持系统整洁。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker system prune -a</pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：此命令会删除所有停止的容器、未使用的网络、悬空镜像以及所有构建缓存。执行前请确保您了解其影响。
</code></pre>
<ol start="6">
<li>
<p><strong>资源限制</strong>：</p>
<p>在<code class="notranslate">docker run</code>命令中为WordPress、MySQL和Nginx容器设置CPU和内存限制，防止单个容器耗尽宿主机资源，影响其他服务。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> WordPress容器的资源限制示例</span>
docker run \
  --name wordpress-app \
  --network wordpress-network \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/wordpress_data:/var/www/html \
  -e WORDPRESS_DB_HOST=mysql-db:3306 \
  -e WORDPRESS_DB_USER=wordpress \
  -e WORDPRESS_DB_PASSWORD=wordpress_password \
  -e WORDPRESS_DB_NAME=wordpress_db \
  --cpus=<span class="pl-s"><span class="pl-pds">"</span>0.5<span class="pl-pds">"</span></span> \
  --memory=<span class="pl-s"><span class="pl-pds">"</span>512m<span class="pl-pds">"</span></span> \
  -d wordpress:latest

<span class="pl-c"><span class="pl-c">#</span> MySQL容器的资源限制示例</span>
docker run \
  --name mysql-db \
  --network wordpress-network \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/db_data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=root_password \
  -e MYSQL_DATABASE=wordpress_db \
  -e MYSQL_USER=wordpress \
  -e MYSQL_PASSWORD=wordpress_password \
  --cpus=<span class="pl-s"><span class="pl-pds">"</span>0.5<span class="pl-pds">"</span></span> \
  --memory=<span class="pl-s"><span class="pl-pds">"</span>1g<span class="pl-pds">"</span></span> \
  -d mysql:8.0

<span class="pl-c"><span class="pl-c">#</span> Nginx容器的资源限制示例</span>
docker run \
  --name nginx-proxy \
  --network wordpress-network \
  -p 80:80 \
  -v <span class="pl-k">~</span>/wordpress-nginx-docker-run/nginx_conf/default.conf:/etc/nginx/conf.d/default.conf:ro \
  --cpus=<span class="pl-s"><span class="pl-pds">"</span>0.2<span class="pl-pds">"</span></span> \
  --memory=<span class="pl-s"><span class="pl-pds">"</span>128m<span class="pl-pds">"</span></span> \
  -d nginx:latest</pre></div>
<h1>二、利用docker compose安装</h1>
<h1>Docker安装WordPress实验手册 (CentOS 8)</h1>
<h2>1. 引言</h2>
<h3>1.1 WordPress简介</h3>
<p>WordPress是一款全球领先的开源内容管理系统（CMS），以其易用性、灵活性和强大的社区支持而闻名。它允许用户轻松创建和管理网站、博客和电子商务平台，无需专业的编程知识。WordPress拥有庞大的主题和插件生态系统，可以满足各种网站建设需求。</p>
<h3>1.2 Docker与WordPress结合的优势</h3>
<p>将WordPress与Docker结合使用，可以带来多方面的优势：</p>
<ul>
<li><strong>环境一致性</strong>：Docker确保WordPress及其依赖（如MySQL）在任何环境中都能以相同的方式运行，避免了“在我机器上可以运行”的问题。</li>
<li><strong>快速部署</strong>：通过Docker Compose，可以一键部署整个WordPress服务栈，大大简化了安装和配置过程。</li>
<li><strong>资源隔离</strong>：每个服务（WordPress、MySQL）都在独立的容器中运行，相互之间隔离，提高了系统的稳定性和安全性。</li>
<li><strong>易于管理</strong>：Docker Compose提供了一套统一的命令来管理整个应用，包括启动、停止、重启和删除，使得维护工作更加便捷。</li>
<li><strong>数据持久化</strong>：通过数据卷机制，可以确保WordPress网站的数据（包括数据库和文件）在容器生命周期之外得到持久化存储，方便备份和迁移。</li>
<li><strong>可移植性</strong>：整个WordPress应用栈可以作为一个整体轻松地在不同的服务器之间迁移。</li>
</ul>
<h3>1.3 实验目的</h3>
<p>本实验手册旨在通过详细的步骤和代码示例，指导您在CentOS 8系统上使用Docker Compose部署一个完整的WordPress网站。具体目标包括：</p>
<ul>
<li><strong>掌握环境准备</strong>：确保CentOS 8系统满足Docker运行要求，并验证Docker和Docker Compose的安装。</li>
<li><strong>学会编写<code class="notranslate">docker-compose.yml</code></strong>：理解WordPress、MySQL和phpMyAdmin服务在Docker Compose中的配置方法。</li>
<li><strong>成功部署WordPress</strong>：通过Docker Compose一键启动WordPress网站，并完成首次安装配置。</li>
<li><strong>理解数据持久化</strong>：掌握数据卷在WordPress和MySQL中的应用，确保数据安全。</li>
<li><strong>了解故障排除与优化</strong>：学习解决常见问题和提升WordPress网站性能的技巧。</li>
</ul>
<p>通过本手册的学习，您将能够自信地在Docker环境中部署和管理WordPress网站，为您的个人项目或企业应用提供强大的支持。</p>
<h1>2. 准备工作</h1>
<p>在开始使用Docker安装WordPress之前，确保您的系统环境已正确配置是至关重要的一步。本章节将指导您检查系统要求、验证Docker和Docker Compose的安装，并创建必要的项目目录。</p>
<h2>2.1 系统要求与Docker环境验证</h2>
<p>本实验手册假设您正在使用 <strong>CentOS 8</strong> 操作系统。为了顺利运行WordPress及其依赖服务（如MySQL），您的系统应满足以下基本要求：</p>
<ul>
<li><strong>操作系统</strong>：CentOS 8 (或兼容的RHEL 8发行版)。</li>
<li><strong>内存</strong>：建议至少2GB RAM，以确保WordPress和MySQL容器能够稳定运行。</li>
<li><strong>磁盘空间</strong>：建议至少20GB可用磁盘空间，用于存储Docker镜像、容器数据以及WordPress文件。</li>
<li><strong>网络连接</strong>：确保系统可以访问互联网，以便拉取Docker镜像。</li>
</ul>
<p>此外，您需要确保系统上已正确安装并配置了Docker Engine和Docker Compose。如果您尚未安装，请参考上一份实验手册《Docker实验手册 (CentOS 8)》中的“Docker安装与配置”章节进行安装和配置，特别是要确保配置了国内镜像加速，以提高镜像拉取速度。</p>
<p>您可以通过以下命令验证Docker Engine和Docker Compose的安装情况：</p>
<ol>
<li><strong>验证Docker Engine</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker version</pre></div>
<pre class="notranslate"><code class="notranslate">如果Docker Engine已正确安装，此命令将显示Docker客户端和服务器的版本信息。请确保服务器版本（Server Version）存在。
</code></pre>
<ol start="2">
<li><strong>验证Docker Compose</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose version</pre></div>
<pre class="notranslate"><code class="notranslate">如果Docker Compose已正确安装，此命令将显示Docker Compose的版本信息。请注意，新版本的Docker Compose作为Docker CLI的插件，命令是`docker compose`（无连字符）。
</code></pre>
<h2>2.2 创建项目目录</h2>
<p>为了更好地组织WordPress项目文件和Docker Compose配置，建议为您的WordPress安装创建一个独立的目录。这个目录将包含<code class="notranslate">docker-compose.yml</code>文件以及WordPress和MySQL的数据持久化目录。</p>
<ol>
<li><strong>创建主项目目录</strong>：</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir <span class="pl-k">~</span>/wordpress-docker
<span class="pl-c1">cd</span> <span class="pl-k">~</span>/wordpress-docker</pre></div>
<pre class="notranslate"><code class="notranslate">此命令将在您的用户主目录下创建一个名为`wordpress-docker`的目录，并进入该目录。所有后续的操作都将在此目录下进行。
</code></pre>
<ol start="2">
<li>
<p><strong>创建数据持久化目录</strong>：</p>
<p>为了确保WordPress和MySQL的数据在容器重建后不会丢失，我们将使用数据卷进行持久化。虽然Docker Compose会自动创建匿名数据卷，但为了方便管理和备份，我们通常会创建具名数据卷或绑定挂载宿主机目录。在这里，我们先创建两个用于绑定挂载的目录，以便后续配置数据卷时使用。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir ./wordpress_data
mkdir ./db_data</pre></div>
<pre class="notranslate"><code class="notranslate">*   `./wordpress_data`：将用于存储WordPress的程序文件、主题、插件和上传内容。
*   `./db_data`：将用于存储MySQL数据库的数据文件。
</code></pre>
<p>完成以上准备工作后，您的系统已为使用Docker Compose部署WordPress做好了充分准备。接下来，我们将开始编写<code class="notranslate">docker-compose.yml</code>文件来定义WordPress服务栈。</p>
<h1>3. 使用Docker Compose安装WordPress</h1>
<p>Docker Compose是部署多容器应用程序的强大工具，它允许您通过一个YAML文件定义和管理WordPress及其依赖服务（如MySQL数据库）。本章节将指导您编写<code class="notranslate">docker-compose.yml</code>文件，并使用它来启动WordPress应用。</p>
<h2>3.1 <code class="notranslate">docker-compose.yml</code> 文件编写</h2>
<p>在您之前创建的<code class="notranslate">~/wordpress-docker</code>目录下，创建一个名为<code class="notranslate">docker-compose.yml</code>的文件。此文件将定义WordPress、MySQL以及可选的phpMyAdmin服务。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c1">cd</span> <span class="pl-k">~</span>/wordpress-docker
cat <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span> &gt; docker-compose.yml</span>
<span class="pl-s">version: '3.8'</span>
<span class="pl-s"></span>
<span class="pl-s">services:</span>
<span class="pl-s">  wordpress:</span>
<span class="pl-s">    image: wordpress:latest</span>
<span class="pl-s">    ports:</span>
<span class="pl-s">      - "80:80"</span>
<span class="pl-s">    environment:</span>
<span class="pl-s">      WORDPRESS_DB_HOST: db</span>
<span class="pl-s">      WORDPRESS_DB_USER: wordpress</span>
<span class="pl-s">      WORDPRESS_DB_PASSWORD: wordpress_password</span>
<span class="pl-s">      WORDPRESS_DB_NAME: wordpress_db</span>
<span class="pl-s">    volumes:</span>
<span class="pl-s">      - ./wordpress_data:/var/www/html</span>
<span class="pl-s">    depends_on:</span>
<span class="pl-s">      - db</span>
<span class="pl-s">    restart: always</span>
<span class="pl-s">    networks:</span>
<span class="pl-s">      - wordpress-network</span>
<span class="pl-s"></span>
<span class="pl-s">  db:</span>
<span class="pl-s">    image: mysql:8.0</span>
<span class="pl-s">    environment:</span>
<span class="pl-s">      MYSQL_ROOT_PASSWORD: root_password</span>
<span class="pl-s">      MYSQL_DATABASE: wordpress_db</span>
<span class="pl-s">      MYSQL_USER: wordpress</span>
<span class="pl-s">      MYSQL_PASSWORD: wordpress_password</span>
<span class="pl-s">    volumes:</span>
<span class="pl-s">      - ./db_data:/var/lib/mysql</span>
<span class="pl-s">    restart: always</span>
<span class="pl-s">    networks:</span>
<span class="pl-s">      - wordpress-network</span>
<span class="pl-s"></span>
<span class="pl-s">  phpmyadmin:</span>
<span class="pl-s">    image: phpmyadmin/phpmyadmin</span>
<span class="pl-s">    ports:</span>
<span class="pl-s">      - "8080:80"</span>
<span class="pl-s">    environment:</span>
<span class="pl-s">      PMA_HOST: db</span>
<span class="pl-s">      MYSQL_ROOT_PASSWORD: root_password</span>
<span class="pl-s">    depends_on:</span>
<span class="pl-s">      - db</span>
<span class="pl-s">    restart: always</span>
<span class="pl-s">    networks:</span>
<span class="pl-s">      - wordpress-network</span>
<span class="pl-s"></span>
<span class="pl-s">networks:</span>
<span class="pl-s">  wordpress-network:</span>
<span class="pl-s">    driver: bridge</span>
<span class="pl-s"></span>
<span class="pl-s">volumes:</span>
<span class="pl-s">  wordpress_data:</span>
<span class="pl-s">  db_data:</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<h2>3.2 文件说明与配置项解析</h2>
<p>上述<code class="notranslate">docker-compose.yml</code>文件定义了三个服务：<code class="notranslate">wordpress</code>、<code class="notranslate">db</code>（MySQL数据库）和<code class="notranslate">phpmyadmin</code>，以及一个自定义网络和两个数据卷。</p>
<h3>3.2.1 <code class="notranslate">wordpress</code> 服务</h3>
<ul>
<li><strong><code class="notranslate">image: wordpress:latest</code></strong>：使用Docker Hub上官方提供的最新版WordPress镜像 [3]。</li>
<li><strong><code class="notranslate">ports: - "80:80"</code></strong>：将宿主机的80端口映射到WordPress容器的80端口，这样可以通过宿主机的IP地址或域名访问WordPress。</li>
<li><strong><code class="notranslate">environment</code></strong>：设置WordPress连接MySQL数据库所需的环境变量。这些变量必须与<code class="notranslate">db</code>服务中定义的数据库信息一致。
<ul>
<li><code class="notranslate">WORDPRESS_DB_HOST: db</code>：指定数据库主机名为<code class="notranslate">db</code>，这是Docker Compose网络中MySQL服务的服务名称。</li>
<li><code class="notranslate">WORDPRESS_DB_USER: wordpress</code>：WordPress连接数据库的用户名。</li>
<li><code class="notranslate">WORDPRESS_DB_PASSWORD: wordpress_password</code>：WordPress连接数据库的密码。</li>
<li><code class="notranslate">WORDPRESS_DB_NAME: wordpress_db</code>：WordPress使用的数据库名称。</li>
</ul>
</li>
<li><strong><code class="notranslate">volumes: - ./wordpress_data:/var/www/html</code></strong>：将宿主机当前目录下的<code class="notranslate">wordpress_data</code>目录绑定挂载到容器内的<code class="notranslate">/var/www/html</code>目录。这是WordPress的安装路径，用于持久化WordPress的核心文件、主题、插件和上传内容。这样即使容器被删除，数据也不会丢失。</li>
<li><strong><code class="notranslate">depends_on: - db</code></strong>：声明<code class="notranslate">wordpress</code>服务依赖于<code class="notranslate">db</code>服务。这意味着<code class="notranslate">db</code>服务会先于<code class="notranslate">wordpress</code>服务启动。</li>
<li><strong><code class="notranslate">restart: always</code></strong>：设置容器的重启策略为<code class="notranslate">always</code>，即无论容器因何种原因停止，都会自动重启。</li>
<li><strong><code class="notranslate">networks: - wordpress-network</code></strong>：将<code class="notranslate">wordpress</code>服务连接到名为<code class="notranslate">wordpress-network</code>的自定义网络。</li>
</ul>
<h3>3.2.2 <code class="notranslate">db</code> 服务 (MySQL数据库)</h3>
<ul>
<li><strong><code class="notranslate">image: mysql:8.0</code></strong>：使用Docker Hub上官方提供的MySQL 8.0镜像 [4]。</li>
<li><strong><code class="notranslate">environment</code></strong>：设置MySQL数据库的环境变量，用于初始化数据库和创建用户。
<ul>
<li><code class="notranslate">MYSQL_ROOT_PASSWORD: root_password</code>：MySQL的root用户密码。</li>
<li><code class="notranslate">MYSQL_DATABASE: wordpress_db</code>：要创建的数据库名称，与WordPress服务中配置的数据库名称一致。</li>
<li><code class="notranslate">MYSQL_USER: wordpress</code>：要创建的数据库用户，与WordPress服务中配置的用户名一致。</li>
<li><code class="notranslate">MYSQL_PASSWORD: wordpress_password</code>：要创建的数据库用户密码，与WordPress服务中配置的密码一致。</li>
</ul>
</li>
<li><strong><code class="notranslate">volumes: - ./db_data:/var/lib/mysql</code></strong>：将宿主机当前目录下的<code class="notranslate">db_data</code>目录绑定挂载到容器内的<code class="notranslate">/var/lib/mysql</code>路径。这是MySQL存储数据的地方，用于持久化数据库内容。</li>
<li><strong><code class="notranslate">restart: always</code></strong>：设置容器的重启策略为<code class="notranslate">always</code>。</li>
<li><strong><code class="notranslate">networks: - wordpress-network</code></strong>：将<code class="notranslate">db</code>服务连接到名为<code class="notranslate">wordpress-network</code>的自定义网络。</li>
</ul>
<h3>3.2.3 <code class="notranslate">phpmyadmin</code> 服务 (可选)</h3>
<ul>
<li><strong><code class="notranslate">image: phpmyadmin/phpmyadmin</code></strong>：使用Docker Hub上官方提供的phpMyAdmin镜像 [5]，这是一个用于管理MySQL数据库的Web界面工具。</li>
<li><strong><code class="notranslate">ports: - "8080:80"</code></strong>：将宿主机的8080端口映射到phpMyAdmin容器的80端口，这样可以通过<code class="notranslate">http://宿主机IP:8080</code>访问phpMyAdmin。</li>
<li><strong><code class="notranslate">environment</code></strong>：设置phpMyAdmin连接MySQL数据库所需的环境变量。
<ul>
<li><code class="notranslate">PMA_HOST: db</code>：指定phpMyAdmin连接的数据库主机名为<code class="notranslate">db</code>。</li>
<li><code class="notranslate">MYSQL_ROOT_PASSWORD: root_password</code>：phpMyAdmin连接MySQL时使用的root用户密码。</li>
</ul>
</li>
<li><strong><code class="notranslate">depends_on: - db</code></strong>：声明<code class="notranslate">phpmyadmin</code>服务依赖于<code class="notranslate">db</code>服务。</li>
<li><strong><code class="notranslate">restart: always</code></strong>：设置容器的重启策略为<code class="notranslate">always</code>。</li>
<li><strong><code class="notranslate">networks: - wordpress-network</code></strong>：将<code class="notranslate">phpmyadmin</code>服务连接到名为<code class="notranslate">wordpress-network</code>的自定义网络。</li>
</ul>
<h3>3.2.4 <code class="notranslate">networks</code> 和 <code class="notranslate">volumes</code> 部分</h3>
<ul>
<li><strong><code class="notranslate">networks: wordpress-network:</code></strong>：定义了一个名为<code class="notranslate">wordpress-network</code>的自定义桥接网络。所有连接到此网络的容器都可以通过服务名称相互通信，例如WordPress容器可以通过<code class="notranslate">db</code>这个名称访问MySQL容器。</li>
<li><strong><code class="notranslate">volumes: wordpress_data:</code> 和 <code class="notranslate">db_data:</code></strong>：定义了两个具名数据卷。虽然我们在这里使用了绑定挂载，但声明这些数据卷有助于Docker Compose管理它们的生命周期，并在某些情况下提供更好的抽象。实际上，由于我们使用了 <code class="notranslate">./wordpress_data</code> 和 <code class="notranslate">./db_data</code> 进行绑定挂载，这些具名数据卷的声明在这里主要是为了完整性，实际数据将存储在宿主机对应的目录下。</li>
</ul>
<h2>3.3 启动WordPress应用</h2>
<p>在<code class="notranslate">docker-compose.yml</code>文件所在的<code class="notranslate">~/wordpress-docker</code>目录下，执行以下命令来启动WordPress应用程序栈：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose up -d</pre></div>
<ul>
<li><code class="notranslate">-d</code> 或 <code class="notranslate">--detach</code>：表示在后台运行容器，这样您可以在终端继续执行其他命令。</li>
</ul>
<p>执行此命令后，Docker Compose将执行以下操作：</p>
<ol>
<li>检查<code class="notranslate">wordpress</code>、<code class="notranslate">mysql</code>和<code class="notranslate">phpmyadmin</code>镜像是否存在。如果不存在，将从Docker Hub拉取它们。</li>
<li>创建<code class="notranslate">wordpress-network</code>网络。</li>
<li>启动<code class="notranslate">db</code>服务（MySQL容器）。</li>
<li>启动<code class="notranslate">wordpress</code>服务（WordPress容器）。</li>
<li>启动<code class="notranslate">phpmyadmin</code>服务（phpMyAdmin容器）。</li>
<li>将宿主机的80端口映射到WordPress容器的80端口，将宿主机的8080端口映射到phpMyAdmin容器的80端口。</li>
</ol>
<p>您可以使用以下命令查看所有服务的运行状态：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose ps</pre></div>
<p>如果所有服务都显示为<code class="notranslate">Up</code>状态，则表示WordPress应用程序已成功启动。</p>
<h1>4. WordPress配置与访问</h1>
<p>在Docker Compose成功启动WordPress服务栈后，您可以通过Web浏览器访问WordPress进行首次安装配置，并可选地通过phpMyAdmin管理数据库。本章节将详细指导这些操作。</p>
<h2>4.1 首次访问WordPress进行安装配置</h2>
<ol>
<li>
<p><strong>打开Web浏览器</strong>：</p>
<p>在您的宿主机上打开任意Web浏览器（如Chrome, Firefox等）。</p>
</li>
<li>
<p><strong>访问WordPress安装页面</strong>：</p>
<p>在浏览器地址栏输入您的宿主机IP地址或<code class="notranslate">localhost</code>。由于我们在<code class="notranslate">docker-compose.yml</code>中将宿主机的80端口映射到了WordPress容器的80端口，因此直接访问即可：</p>
</li>
</ol>
<pre class="notranslate"><code class="notranslate">http://localhost
</code></pre>
<pre class="notranslate"><code class="notranslate">或者，如果您是在远程服务器上操作，请替换`localhost`为您的服务器IP地址：
</code></pre>
<pre class="notranslate"><code class="notranslate">http://&lt;您的服务器IP地址&gt;
</code></pre>
<ol start="3">
<li>
<p><strong>选择语言</strong>：</p>
<p>首次访问时，WordPress会提示您选择安装语言。选择您偏好的语言（例如“简体中文”），然后点击“继续”。</p>
</li>
<li>
<p><strong>欢迎页面</strong>：</p>
<p>您将看到WordPress的欢迎页面，提示您需要数据库信息。点击“现在就开始！”。</p>
</li>
<li>
<p><strong>数据库连接信息</strong>：</p>
<p>在数据库连接信息页面，填写以下内容：</p>
<ul>
<li><strong>数据库名</strong>：<code class="notranslate">wordpress_db</code> (与<code class="notranslate">docker-compose.yml</code>中<code class="notranslate">MYSQL_DATABASE</code>一致)</li>
<li><strong>用户名</strong>：<code class="notranslate">wordpress</code> (与<code class="notranslate">docker-compose.yml</code>中<code class="notranslate">MYSQL_USER</code>一致)</li>
<li><strong>密码</strong>：<code class="notranslate">wordpress_password</code> (与<code class="notranslate">docker-compose.yml</code>中<code class="notranslate">MYSQL_PASSWORD</code>一致)</li>
<li><strong>数据库主机</strong>：<code class="notranslate">db</code> (这是Docker Compose网络中MySQL服务的服务名称)</li>
<li><strong>表前缀</strong>：<code class="notranslate">wp_</code> (保持默认或自定义，不影响功能)</li>
</ul>
<p>填写完毕后，点击“提交”。</p>
</li>
<li>
<p><strong>运行安装</strong>：</p>
<p>如果数据库连接成功，您将看到“运行安装”页面。点击“运行安装”。</p>
</li>
<li>
<p><strong>站点信息</strong>：</p>
<p>填写您的站点信息：</p>
<ul>
<li><strong>站点标题</strong>：您的网站名称 (例如：<code class="notranslate">我的Docker WordPress博客</code>)</li>
<li><strong>用户名</strong>：WordPress后台登录用户名 (例如：<code class="notranslate">admin</code>)</li>
<li><strong>密码</strong>：WordPress后台登录密码 (请设置一个强密码并牢记)</li>
<li><strong>您的电子邮件</strong>：用于接收通知和密码重置 (例如：<code class="notranslate">your_email@example.com</code>)</li>
<li><strong>搜索引擎可见性</strong>：根据需要勾选或取消勾选“建议搜索引擎不索引本站点”（通常在开发阶段勾选，生产环境取消勾选）。</li>
</ul>
<p>填写完毕后，点击“安装WordPress”。</p>
</li>
<li>
<p><strong>安装成功</strong>：</p>
<p>安装成功后，您将看到“成功！”页面。点击“登录”即可进入WordPress后台管理界面。</p>
</li>
</ol>
<p>至此，您的WordPress网站已通过Docker Compose成功安装并运行。</p>
<h2>4.2 (可选) 访问phpMyAdmin管理数据库</h2>
<p>如果您在<code class="notranslate">docker-compose.yml</code>中包含了phpMyAdmin服务，您可以通过Web浏览器访问它来管理WordPress的数据库。</p>
<ol>
<li>
<p><strong>打开Web浏览器</strong>：</p>
<p>在您的宿主机上打开任意Web浏览器。</p>
</li>
<li>
<p><strong>访问phpMyAdmin</strong>：</p>
<p>在浏览器地址栏输入您的宿主机IP地址或<code class="notranslate">localhost</code>，并加上phpMyAdmin映射的端口号（默认为8080）：</p>
</li>
</ol>
<pre class="notranslate"><code class="notranslate">http://localhost:8080
</code></pre>
<pre class="notranslate"><code class="notranslate">或者，如果您是在远程服务器上操作，请替换`localhost`为您的服务器IP地址：
</code></pre>
<pre class="notranslate"><code class="notranslate">http://&lt;您的服务器IP地址&gt;:8080
</code></pre>
<ol start="3">
<li>
<p><strong>登录phpMyAdmin</strong>：</p>
<p>在phpMyAdmin登录页面，填写以下内容：</p>
<ul>
<li><strong>用户名</strong>：<code class="notranslate">root</code> (这是MySQL的root用户)</li>
<li><strong>密码</strong>：<code class="notranslate">root_password</code> (与<code class="notranslate">docker-compose.yml</code>中<code class="notranslate">MYSQL_ROOT_PASSWORD</code>一致)</li>
</ul>
<p>填写完毕后，点击“登录”。</p>
</li>
<li>
<p><strong>管理数据库</strong>：</p>
<p>登录成功后，您将看到phpMyAdmin的管理界面。在左侧导航栏中，您可以找到<code class="notranslate">wordpress_db</code>数据库，并可以查看、编辑其中的表和数据。这对于数据库的调试和管理非常有用。</p>
</li>
</ol>
<p>通过本章节，您已经完成了WordPress的首次安装和配置，并学会了如何使用phpMyAdmin管理其底层数据库。</p>
<h1>5. 数据持久化与备份</h1>
<p>对于任何生产环境的应用程序，数据持久化和备份都是至关重要的环节。WordPress作为一个内容管理系统，其核心数据（文章、页面、用户、配置等）存储在MySQL数据库中，而其文件数据（主题、插件、上传的媒体文件等）则存储在文件系统中。本章节将回顾我们在<code class="notranslate">docker-compose.yml</code>中如何实现数据持久化，并简要介绍备份策略。</p>
<h2>5.1 数据持久化的重要性</h2>
<p>Docker容器的设计理念是轻量级和无状态的。这意味着容器在停止或删除后，其内部写入的所有数据都会丢失。对于WordPress和MySQL这类需要存储数据的应用，如果数据不进行持久化，那么每次容器重建或更新都会导致数据丢失，这是不可接受的。</p>
<p>Docker提供了**数据卷（Volumes）**机制来解决这个问题。数据卷是宿主机文件系统中的一个特殊目录，它可以被挂载到容器内部的指定路径。数据卷独立于容器的生命周期，即使容器被删除，数据卷中的数据依然存在，从而实现了数据的持久化存储。</p>
<h2>5.2 WordPress和MySQL数据卷配置回顾</h2>
<p>在<code class="notranslate">docker-compose.yml</code>文件中，我们通过<code class="notranslate">volumes</code>配置项为WordPress和MySQL服务配置了数据持久化：</p>
<div class="highlight highlight-source-yaml"><pre class="notranslate"><span class="pl-ent">services</span>:
  <span class="pl-ent">wordpress</span>:
    <span class="pl-c"><span class="pl-c">#</span> ... 其他配置 ...</span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s">./wordpress_data:/var/www/html</span>
    <span class="pl-c"><span class="pl-c">#</span> ... 其他配置 ...</span>

  <span class="pl-ent">db</span>:
    <span class="pl-c"><span class="pl-c">#</span> ... 其他配置 ...</span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s">./db_data:/var/lib/mysql</span>
    <span class="pl-c"><span class="pl-c">#</span> ... 其他配置 ...</span></pre></div>
<ul>
<li>
<p><strong>WordPress数据持久化</strong>：</p>
<ul>
<li><code class="notranslate">./wordpress_data:/var/www/html</code>：这行配置将宿主机上<code class="notranslate">~/wordpress-docker/wordpress_data</code>目录（我们在准备工作中创建的）绑定挂载到WordPress容器内部的<code class="notranslate">/var/www/html</code>路径。WordPress的所有程序文件、主题、插件、上传的媒体文件等都将存储在这个宿主机目录中。这意味着您可以直接在宿主机上访问和管理这些文件，并且在WordPress容器被删除或更新后，这些数据依然会保留。</li>
</ul>
</li>
<li>
<p><strong>MySQL数据持久化</strong>：</p>
<ul>
<li><code class="notranslate">./db_data:/var/lib/mysql</code>：这行配置将宿主机上<code class="notranslate">~/wordpress-docker/db_data</code>目录绑定挂载到MySQL容器内部的<code class="notranslate">/var/lib/mysql</code>路径。MySQL数据库的所有数据文件（包括<code class="notranslate">wordpress_db</code>数据库中的所有表和数据）都将存储在这个宿主机目录中。同样，这确保了数据库数据在MySQL容器被删除或更新后不会丢失。</li>
</ul>
</li>
</ul>
<p>通过这种方式，我们确保了WordPress网站的所有关键数据都存储在宿主机的文件系统中，从而实现了数据的持久化。</p>
<h2>5.3 简要备份策略</h2>
<p>尽管数据已经持久化，但为了应对宿主机故障、误操作或数据损坏等情况，定期备份这些持久化数据仍然是必不可少的。以下是一些简单的备份策略：</p>
<ol>
<li>
<p><strong>备份WordPress文件数据</strong>：</p>
<p>由于WordPress的文件数据存储在宿主机的<code class="notranslate">~/wordpress-docker/wordpress_data</code>目录下，您只需定期备份这个目录即可。可以使用<code class="notranslate">tar</code>命令进行打包压缩，并将其存储到安全的位置（例如，远程存储、云存储或另一个物理磁盘）。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 停止WordPress容器以确保文件一致性（可选，但推荐）</span>
docker compose stop wordpress

<span class="pl-c"><span class="pl-c">#</span> 备份WordPress文件</span>
tar -czvf wordpress_files_backup_<span class="pl-s"><span class="pl-pds">$(</span>date +%Y%m%d<span class="pl-pds">)</span></span>.tar.gz <span class="pl-k">~</span>/wordpress-docker/wordpress_data

<span class="pl-c"><span class="pl-c">#</span> 启动WordPress容器</span>
docker compose start wordpress</pre></div>
<ol start="2">
<li>
<p><strong>备份MySQL数据库数据</strong>：</p>
<p>备份MySQL数据库的最佳实践是使用<code class="notranslate">mysqldump</code>工具。您可以在MySQL容器内部执行<code class="notranslate">mysqldump</code>命令，将数据库导出为SQL文件，然后将该文件复制到宿主机进行备份。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 在MySQL容器内部执行mysqldump命令</span>
docker <span class="pl-c1">exec</span> db mysqldump -u wordpress -pwordpress_password wordpress_db <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/wordpress-docker/db_data/wordpress_db_backup_<span class="pl-s"><span class="pl-pds">$(</span>date +%Y%m%d<span class="pl-pds">)</span></span>.sql

<span class="pl-c"><span class="pl-c">#</span> 此时，备份文件已在宿主机的 ~/wordpress-docker/db_data 目录下</span>
<span class="pl-c"><span class="pl-c">#</span> 您可以进一步将此SQL文件移动或复制到其他备份位置</span></pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：上述`mysqldump`命令中的`wordpress`是数据库用户名，`wordpress_password`是密码，`wordpress_db`是数据库名，这些都应与`docker-compose.yml`中配置的一致。备份文件被直接写入到`db_data`目录，因此它会持久化在宿主机上。
</code></pre>
<ol start="3">
<li>
<p><strong>自动化备份</strong>：</p>
<p>为了确保备份的及时性和可靠性，建议将上述备份命令编写成脚本，并结合<code class="notranslate">cron</code>等工具进行自动化调度，实现定期自动备份。</p>
</li>
</ol>
<p>通过实施有效的数据持久化和备份策略，您可以大大提高WordPress网站的健壮性和数据安全性，确保在发生意外情况时能够迅速恢复服务。</p>
<h1>6. 故障排除与优化</h1>
<p>在使用Docker部署WordPress时，可能会遇到各种问题，例如容器无法启动、端口冲突或数据库连接失败等。本章节将提供一些常见的故障排除方法和优化建议，帮助您确保WordPress网站的稳定运行和良好性能。</p>
<h2>6.1 常见问题及解决方案</h2>
<h3>6.1.1 容器无法启动</h3>
<p>当您执行 <code class="notranslate">docker compose up -d</code> 后，如果发现某些服务没有成功启动，可以按照以下步骤进行排查：</p>
<ol>
<li>
<p><strong>查看服务日志</strong>：</p>
<p>这是排查容器启动问题的首要步骤。通过查看容器的日志输出，通常可以找到启动失败的具体原因。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs <span class="pl-k">&lt;</span>服务名称<span class="pl-k">&gt;</span></pre></div>
<pre class="notranslate"><code class="notranslate">例如，查看WordPress服务的日志：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs wordpress</pre></div>
<pre class="notranslate"><code class="notranslate">查看数据库服务的日志：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs db</pre></div>
<pre class="notranslate"><code class="notranslate">日志中可能会显示配置错误、依赖缺失或权限问题等信息。
</code></pre>
<ol start="2">
<li>
<p><strong>检查端口冲突</strong>：</p>
<p>如果日志显示端口被占用，可能是宿主机上的其他进程占用了WordPress或phpMyAdmin所需的端口（默认为80和8080）。</p>
<ul>
<li><strong>识别占用端口的进程</strong>：</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo netstat -tulnp <span class="pl-k">|</span> grep :80
sudo netstat -tulnp <span class="pl-k">|</span> grep :8080</pre></div>
<pre class="notranslate"><code class="notranslate">*   **解决方案**：
    *   停止占用端口的进程。
    *   修改`docker-compose.yml`文件中WordPress或phpMyAdmin服务的端口映射，例如将WordPress的80端口映射到宿主机的8081端口：
</code></pre>
<div class="highlight highlight-source-yaml"><pre class="notranslate"><span class="pl-ent">wordpress</span>:
  <span class="pl-ent">ports</span>:
    - <span class="pl-s"><span class="pl-pds">"</span>8081:80<span class="pl-pds">"</span></span></pre></div>
<pre class="notranslate"><code class="notranslate">    修改后，需要重新构建并启动服务：
</code></pre>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose up -d --build</pre></div>
<ol start="3">
<li>
<p><strong>检查<code class="notranslate">docker-compose.yml</code>文件语法</strong>：</p>
<p>YAML文件对格式和缩进非常敏感。即使是很小的语法错误也可能导致服务无法启动。</p>
<ul>
<li><strong>验证语法</strong>：</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose config --quiet</pre></div>
<pre class="notranslate"><code class="notranslate">    如果命令没有输出任何内容，则表示`docker-compose.yml`文件语法正确。如果有错误，它会打印出详细的错误信息。

*   **解决方案**：根据错误信息修正`docker-compose.yml`文件中的语法错误。
</code></pre>
<h3>6.1.2 数据库连接问题</h3>
<p>WordPress网站显示“Error establishing a database connection”（建立数据库连接错误）是常见问题。这通常是由于WordPress容器无法连接到MySQL数据库容器造成的。</p>
<ol>
<li>
<p><strong>检查环境变量</strong>：</p>
<p>确保<code class="notranslate">wordpress</code>服务中的数据库连接环境变量与<code class="notranslate">db</code>服务中的MySQL配置完全一致。</p>
<ul>
<li><code class="notranslate">WORDPRESS_DB_HOST</code>：必须是MySQL服务的服务名称，即<code class="notranslate">db</code>。</li>
<li><code class="notranslate">WORDPRESS_DB_USER</code>：必须与<code class="notranslate">MYSQL_USER</code>一致。</li>
<li><code class="notranslate">WORDPRESS_DB_PASSWORD</code>：必须与<code class="notranslate">MYSQL_PASSWORD</code>一致。</li>
<li><code class="notranslate">WORDPRESS_DB_NAME</code>：必须与<code class="notranslate">MYSQL_DATABASE</code>一致。</li>
</ul>
</li>
<li>
<p><strong>检查网络连接</strong>：</p>
<p>确保<code class="notranslate">wordpress</code>和<code class="notranslate">db</code>服务都连接到同一个Docker网络（例如<code class="notranslate">wordpress-network</code>）。您可以通过进入WordPress容器并尝试ping数据库服务来验证网络连通性：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker <span class="pl-c1">exec</span> -it <span class="pl-k">&lt;</span>wordpress容器ID或名称<span class="pl-k">&gt;</span> bash
ping db
<span class="pl-c1">exit</span></pre></div>
<pre class="notranslate"><code class="notranslate">如果`ping db`失败，则表示网络配置有问题。
</code></pre>
<ol start="3">
<li>
<p><strong>检查MySQL服务状态</strong>：</p>
<p>确保MySQL容器正在运行且没有错误。查看<code class="notranslate">db</code>服务的日志：</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker compose logs db</pre></div>
<pre class="notranslate"><code class="notranslate">如果MySQL服务启动失败，WordPress自然无法连接。
</code></pre>
<h3>6.1.3 WordPress权限问题</h3>
<p>有时WordPress在安装主题、插件或上传媒体文件时可能会遇到权限问题。</p>
<ol>
<li>
<p><strong>检查数据卷权限</strong>：</p>
<p>确保宿主机上<code class="notranslate">~/wordpress-docker/wordpress_data</code>目录的权限允许WordPress容器内的用户写入。WordPress容器通常以<code class="notranslate">www-data</code>用户运行。</p>
<ul>
<li><strong>解决方案</strong>：更改宿主机上<code class="notranslate">wordpress_data</code>目录的所有者为Docker容器内WordPress进程的用户ID（通常是33，对应<code class="notranslate">www-data</code>用户），或者给予更宽松的权限（不推荐在生产环境使用）。</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">sudo chown -R 33:33 <span class="pl-k">~</span>/wordpress-docker/wordpress_data
<span class="pl-c"><span class="pl-c">#</span> 或者，如果不知道确切UID/GID，可以尝试更宽松的权限（生产环境不推荐）</span>
sudo chmod -R 777 <span class="pl-k">~</span>/wordpress-docker/wordpress_data</pre></div>
<h2>6.2 性能优化建议</h2>
<p>为了提高Docker化WordPress网站的性能和响应速度，可以考虑以下优化措施：</p>
<ol>
<li>
<p><strong>使用高性能数据卷</strong>：</p>
<p>对于生产环境，建议将<code class="notranslate">wordpress_data</code>和<code class="notranslate">db_data</code>目录放置在SSD硬盘上，以提高文件I/O和数据库读写性能。</p>
</li>
<li>
<p><strong>配置WordPress缓存插件</strong>：</p>
<p>安装并配置WordPress缓存插件（如WP Super Cache, W3 Total Cache, LiteSpeed Cache等），可以显著减少数据库查询和页面生成时间，提高网站加载速度。</p>
</li>
<li>
<p><strong>优化MySQL配置</strong>：</p>
<p>根据您的服务器资源和WordPress网站的负载情况，调整MySQL容器的配置参数（例如<code class="notranslate">innodb_buffer_pool_size</code>），以优化数据库性能。这可以通过在<code class="notranslate">docker-compose.yml</code>中为<code class="notranslate">db</code>服务添加<code class="notranslate">command</code>或<code class="notranslate">config</code>文件挂载来实现。</p>
</li>
<li>
<p><strong>使用CDN</strong>：</p>
<p>对于静态资源（图片、CSS、JavaScript），使用内容分发网络（CDN）可以加快全球用户的访问速度，并减轻服务器负载。</p>
</li>
<li>
<p><strong>定期清理Docker资源</strong>：</p>
<p>定期清理不再使用的Docker镜像、容器和数据卷，可以释放磁盘空间，保持系统整洁。</p>
</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">docker system prune -a</pre></div>
<pre class="notranslate"><code class="notranslate">**注意**：此命令会删除所有停止的容器、未使用的网络、悬空镜像以及所有构建缓存。执行前请确保您了解其影响。
</code></pre>
<ol start="6">
<li>
<p><strong>资源限制</strong>：</p>
<p>在<code class="notranslate">docker-compose.yml</code>中为WordPress和MySQL服务设置CPU和内存限制，防止单个容器耗尽宿主机资源，影响其他服务。</p>
</li>
</ol>
<div class="highlight highlight-source-yaml"><pre class="notranslate"><span class="pl-ent">wordpress</span>:
  <span class="pl-c"><span class="pl-c">#</span> ...</span>
  <span class="pl-ent">deploy</span>:
    <span class="pl-ent">resources</span>:
      <span class="pl-ent">limits</span>:
        <span class="pl-ent">cpus</span>: <span class="pl-s"><span class="pl-pds">'</span>0.5<span class="pl-pds">'</span></span>
        <span class="pl-ent">memory</span>: <span class="pl-c1">512M</span>

<span class="pl-ent">db</span>:
  <span class="pl-c"><span class="pl-c">#</span> ...</span>
  <span class="pl-ent">deploy</span>:
    <span class="pl-ent">resources</span>:
      <span class="pl-ent">limits</span>:
        <span class="pl-ent">cpus</span>: <span class="pl-s"><span class="pl-pds">'</span>0.5<span class="pl-pds">'</span></span>
        <span class="pl-ent">memory</span>: <span class="pl-c1">1G</span></pre></div>
<p>通过掌握这些故障排除技巧和性能优化建议，您将能够更有效地管理和维护您的Docker化WordPress网站，确保其稳定、高效地运行。</p>
<h1>7. 总结与展望</h1>
<p>本实验手册详细介绍了如何在CentOS 8系统上，利用Docker Compose快速、高效地部署WordPress网站。通过本次实验，您应该已经掌握了以下关键技能和概念：</p>
<ul>
<li><strong>环境准备</strong>：了解了Docker化WordPress的系统要求，并学会了验证Docker和Docker Compose的安装。</li>
<li><strong>Docker Compose应用</strong>：掌握了<code class="notranslate">docker-compose.yml</code>文件的编写，理解了如何定义WordPress、MySQL和phpMyAdmin服务，以及如何配置网络和数据卷。</li>
<li><strong>WordPress安装与配置</strong>：成功启动了WordPress服务栈，并通过Web界面完成了WordPress的首次安装和基本配置。</li>
<li><strong>数据持久化</strong>：深入理解了数据卷在Docker环境中实现数据持久化的重要性，并回顾了WordPress和MySQL数据卷的配置。</li>
<li><strong>故障排除与优化</strong>：学习了如何诊断和解决常见的Docker和WordPress部署问题，并获得了一些性能优化的建议。</li>
</ul>
<p>通过Docker Compose部署WordPress，不仅简化了部署流程，还提供了环境隔离、易于管理和高度可移植性等诸多优势。这使得WordPress网站的开发、测试和生产环境能够保持高度一致，大大提高了工作效率和系统稳定性。</p>
<h2>7.1 展望</h2>
<p>Docker和容器技术在Web应用部署领域正发挥着越来越重要的作用。未来，您可以进一步探索以下方向，以提升您的Docker和WordPress应用水平：</p>
<ul>
<li><strong>HTTPS配置</strong>：为您的WordPress网站配置SSL/TLS证书，实现HTTPS加密访问，提高网站安全性。这通常可以通过Nginx反向代理容器结合Let's Encrypt实现。</li>
<li><strong>负载均衡与高可用</strong>：在生产环境中，可以考虑使用Docker Swarm或Kubernetes等容器编排工具，实现WordPress网站的负载均衡和高可用性，以应对高并发访问。</li>
<li><strong>CI/CD集成</strong>：将Docker化WordPress的部署流程集成到持续集成/持续部署（CI/CD）管道中，实现自动化测试和部署。</li>
<li><strong>性能监控</strong>：利用Prometheus、Grafana等监控工具，对WordPress容器的性能指标进行实时监控，及时发现并解决潜在问题。</li>
<li><strong>自定义镜像</strong>：根据特定需求，创建自定义的WordPress或MySQL Docker镜像，预装常用插件、主题或优化配置。</li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://bbs.017121.xyz">Gweek</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","igweek/igweek.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
